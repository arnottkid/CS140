<title>CS140 Lecture notes -- Linked Data Structures (Stacks/Queues/Lists)</title>
<body bgcolor=ffffff>
<h2>CS140 Lecture notes -- Linked Data Structures (Stacks/Queues/Lists)</h2>
<LI><a href=http://web.eecs.utk.edu/~jplank>James S. Plank</a>
<LI>Directory: <b>/home/jplank/cs140/Notes/Stack-Queue</b>
<LI>Lecture notes:
    <a href=http://web.eecs.utk.edu/~jplank/plank/classes/cs140/Notes/Linked/>
    <b>http://web.eecs.utk.edu/~jplank/plank/classes/cs140/Notes/Linked/</b></a>
<LI> Original Notes: <i> Mon Mar 12 17:00:19 EDT 2012
</i>
<LI> Last Modification: <i> 
Sun Oct 20 14:30:40 EDT 2019
</i>
<hr>

Time to look beneath the hood.  While the standard template library is a
great tool, it's important to understand how dynamic data structures like
lists and trees are actually implemented.  We'll start with two simple
data structures -- <i>Stacks</i> and <i>Queues</i> -- and how we implement
them without any help from the standard template library.  We then demonstrate
how to implement doubly linked lists, which is how the STL <b>list</b> 
data structure is implemented.
<p>
One of the nice parts of the standard template library is that it works
with all data types.  We're going to pare it down, and have our data structures
only hold strings.

<hr>
<h2>Stacks</h2>

A stack is a "LIFO" -- "Last in, first out" data structure.  It supports two
main operations:
<p>
<UL>
<LI> <b>void Push(const string &amp;s)</b>:  The adds a string to the stack.
<LI> <b>string Pop()</b>: This returns the most recently added string.
</UL>
<p>
The full stack API is in 
<b><a href=include/stack.hpp>include/stack.hpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#pragma once
#include &lt;string&gt;

<font color=blue>/* Ignore the Stacknode class for now.  I'll get around to it when we need it. */</font>

class Stacknode {
  public:
    std::string s;
    Stacknode *next;
};

<font color=blue>/* Here is the stack class.  This is a data structure that holds strings in a
  "Last in, first out" manner.  */</font>

class Stack {
  public:
 
    Stack();                               <font color=blue>// Regular constructor</font>
    Stack(const Stack &s);                 <font color=blue>// Copy constructor</font>
    Stack& operator= (const Stack &s);     <font color=blue>// Assignment overload</font>
    ~Stack();                              <font color=blue>// Destructor</font>
    void Clear();                          <font color=blue>// Clear it out</font>

    void Push(const std::string &s);   <font color=blue>// This puts a string on the stack.</font>
    std::string Pop();                 <font color=blue>// This removes a string from the stack.</font>

    bool Empty() const;                <font color=blue>// These return information about the stack.</font>
    size_t Size() const;
  protected:
    Stacknode *top;                    <font color=blue>// This is how the stack is implemented.</font>
    size_t size;
};
</pre></td></table></center><p>

Ignore the "Stacknode" stuff for now.  Just concentrate on the public methods for the
stack.  Besides the <b>Push()</b> and <b>Pop()</b> methods, there are straightforward <b>Clear()</b>, <b>Empty()</b> and <b>Size()</b> methods, plus the full complement of constructors, destructor and
assignment overload.
<p>
A simple application that uses a stack is a program that reverses standard input --
you read each line and push it onto a stack, and then pop each string from the 
stack, printing as you go.  The code is in 
<b><a href=src/stack_rev.cpp>src/stack_rev.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include "stack.hpp"
#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s;
  Stack st;

  <font color=blue>/* Create the stack with every line of standard input. */</font>

  while (getline(cin, s)) st.Push(s);

  <font color=blue>/* Now, pop each string off the stack and print it out.
     This will print standard output in reverse order. */</font>

  while (!st.Empty()) cout &lt;&lt; st.Pop() &lt;&lt; endl;

  return 0;
}
</pre></td></table></center><p>

It's nice when a data structure so naturally fits an application.  That's
some clean code.
<hr>
<h3>Implementation</h3>

Now let's look at the implementation.  Each value that gets stored on the
stack is going to be stored in a single instance of the <b>Stacknode</b> class, which
we'll revisit here (it was defined above in 
<b><a href=include/stack.hpp>include/stack.hpp</a></b>).

<p><center><table border=3 cellpadding=3><td><pre>
class Stacknode {
  public:
    std::string s;
    Stacknode *next;
};
</pre></td></table></center><p>

You'll note that one protected member variable of the stack is a pointer to
a <b>Stacknode</b>, called <b>top</b>.  This is going to point to a <b>Stacknode</b>
whose string <b>s</b> is the last string that was pushed onto the stack.  
The 
a <b>Stacknode's</b> pointer <b>next</b> is going to point to the string that was
pushed before the most recent one, and so on.  The final <b>Stacknode's</b> <b>next</b>
pointer will be <b>NULL</b>.  If the stack is empty, then <b>top</b> will be <b>NULL</b>
<p>
For example, suppose we do:

<p><center><table border=3 cellpadding=3><td><pre>
Stack st;

st.Push("Give");
st.Push("Him");
st.Push("Six");
</pre></td></table></center><p>

Our stack is going to look as follows:

<p><center><table border=0><td><img src=jpg/Stack-1.jpg></td></table></center><p>

The reason that we have this structure is that it facilitates adding new <b>Stacknode</b>'s
via <b>Push()</b>, and removing them via <b>Pop()</b>.  Let's consider <b>Push()</b>.  Here's
the code (in <b><a href=stack.cpp>stack.cpp</a></b>):

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* Push allocates a new node, whose pointer points to the current top of the stack.
   Then, it sets the top of the stack to this new node. */</font>

void Stack::Push(const string &s)
{
  Stacknode *newnode;

  newnode = new Stacknode;
  newnode-&gt;s = s;
  newnode-&gt;next = top;
  top = newnode;
  size++;
}
</pre></td></table></center><p>

What this does is create a new node with the given string, and hook that node on to the
top of the stack.  Consider calling <b>Push("Now")</b> on the stack above.  We'll go through
each step:

<p><center><table border=3 cellpadding=6><tr><td><img src=jpg/Stack-2.jpg></td><tr>
<tr><td><img src=jpg/Stack-3.jpg></td><tr>
<tr><td><img src=jpg/Stack-4.jpg></td><tr></table></center><p>

When <b>Push()</b> returns, the variable <b>newnode</b> goes away, and we are left with 
a stack that has "Now" on top:


<p><center><table border=0><tr><td><img src=jpg/Stack-5.jpg></td><tr></table></center><p>

<b>Pop()</b> on the other hand, needs to store the string that is on the first node,
remove that node from the stack, and return the stored string.  Since <b>Push()</b>
called <b>new</b>, <b>Pop()</b> must call <b>delete</b>.  Otherwise, our stack implementation
will have a memory leak.  
<p>
Here's the code:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* Pop "unhooks" the top node from the stack, sets s to the string on top,
   and then deletes it.  It throws an exception if the stack is empty.
   That is because it's the user of the stack making a mistake, and throwing
   the exception is a clean way of handling the error. */</font>

string Stack::Pop()
{
  string rv;
  Stacknode *oldtop;

  if (top == NULL) throw((string) "Stack::Pop() called on an empty stack");

  oldtop = top;
  top = oldtop-&gt;next;
  rv = oldtop-&gt;s;
  delete oldtop;

  size--;
  return rv;
}
</pre></td></table></center><p>
And below we step through <b>Pop()</b> called on the original three-node stack:

<p><center><table border=3 cellpadding=6><tr><td><img src=jpg/Stack-6.jpg></td><tr>
<tr><td><img src=jpg/Stack-7.jpg></td><tr>
<tr><td><img src=jpg/Stack-8.jpg></td><tr></table></center><p>

When we're done, we return "Six" to the caller, and our stack only has two elements:

<p><center><table border=0><td><img src=jpg/Stack-9.jpg></td></table></center><p>

Be sure you understand how these two methods work.  Understanding linked data structures
is a fundamental concept, and this is the easiest example.  You need to understand it before
you can move on.
<p>
The regular constructor, <b>Empty()</b> and <b>Print()</b> are straightforward:
<p><center><table border=3 cellpadding=3><td valign=top><pre>
Stack::Stack()
{
  top = NULL;
  size = 0;
}
</pre></td><td valign=top><pre>
bool Stack::Empty()
{
  return (size == 0);
}
</pre></td><td valign=top><pre>
size_t Stack::Size()
{
  return size;
}
</pre></td></table></center><p>

The other methods are a little subtle.  Let's first concentrate on <b>Clear()</b>, which
converts a potentially non-empty stack to an empty one.  I could implement <b>Clear()</b>
very easily:

<p><center><table border=3 cellpadding=3><td><pre>
void Stack::Clear()
{
  while (!Empty()) (void) Pop();
}
</pre></td></table></center><p>

However, I'm going to implement it more efficiently, without making all of those
method calls.  Instead, I'm going to keep deleting the top of the stack until there
are no more nodes on the stack.  You'll note, I need the <b>next</b> variable to 
keep track of the "next" node, because after I delete <b>top</b>, <b>top</b> is no
longer a valid pointer:

<p><center><table border=3 cellpadding=3><td><pre>
void Stack::Clear()
{
  Stacknode *next;

  while (top != NULL) {
    next = top-&gt;next;
    delete top;
    top = next;
  }
  size = 0;
}
</pre></td></table></center><p>

The destructor is simple now -- it just calls <b>Clear()</b>:

<p><center><table border=3 cellpadding=3><td><pre>
Stack::~Stack()
{
  Clear();
}
</pre></td></table></center><p>

<p>
We'll stop here, and check that 
<b><a href=src/stack_rev.cpp>src/stack_rev.cpp</a></b> works:

<pre>
UNIX> <font color=darkred><b>make bin/stack_rev</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/stack_rev.o src/stack_rev.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/stack.o src/stack.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/stack_rev obj/stack_rev.o obj/stack.o
UNIX> <font color=darkred><b>head -n 5 txt/input.txt </b></font>
 0  John Eighth
 1  Tristan Passenger
 2  Joshua Classroom
 3  Oliver Andrew Propagandist
 4  Tristan Tristan Hieratic
UNIX> <font color=darkred><b>head -n 5 txt/input.txt | bin/stack_rev</b></font>
 4  Tristan Tristan Hieratic
 3  Oliver Andrew Propagandist
 2  Joshua Classroom
 1  Tristan Passenger
 0  John Eighth
UNIX> <font color=darkred><b></b></font>
</pre>

You'll note, this does call the destructor, when <b>main()</b> returns.
<hr>
<h3>The Copy Constructor and Assignment Overload</h3>

As with all data structures, you need to evaluate whether or not you need a copy 
constructor and assignment overload.  To help you think about this, take a look
at <b><a href=src/stack_overload.cpp>src/stack_overload.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include "stack.hpp"
#include &lt;iostream&gt;
using namespace std;

<font color=blue>/* This program demonstrates the assignment overload in action. */</font>

int main()
{
  string s;
  Stack s1, s2;

  <font color=blue>/* Read standard input into a stack. */</font>

  while (getline(cin, s)) s1.Push(s);

  <font color=blue>/* Copy the stack and clear out the original stack */</font>

  s2 = s1;
  s1.Clear();

  <font color=blue>/* Print the copied stack */</font>

  while (!s2.Empty()) {
    cout &lt;&lt; s2.Pop() &lt;&lt; endl;
  }
  return 0;
}
</pre></td></table></center><p>

When we say "<b>s2 = s1</b>", and we don't implement an assignment overload, then
<b>s2</b> gets a copy of <b>s1</b>'s member variables, which means a copy of <b>size</b>
and a copy of <b>top</b>.  Now you have two data structures pointing to the same 
memory (<b>s1.top</b> and <b>s2.top</b>), which is a problem.  Why?  Well, what happens
when one of them deletes <b>top</b>?  Then the other one has a stale pointer.
<p>
To highlight that, I have copied: 
<UL>
<LI> <b><a href=include/stack.hpp>include/stack.hpp</a></b> to <b><a href=include/stack_no_ao_or_cc.hpp>include/stack_no_ao_or_cc.hpp</a></b>.
<LI> <b><a href=src/stack.cpp>src/stack.cpp</a></b> to <b><a href=src/stack_no_ao_or_cc.cpp>src/stack_no_ao_or_cc.cpp</a></b>.
<LI> <b><a href=src/stack_overload.cpp>src/stack_overload.cpp</a></b> to <b><a href=src/stack_overload_naoc.cpp>src/stack_overload_naoc.cpp</a></b>
</UL>

In these, I have deleted the assignment overload and copy constructor, so that 
the "<b>s2 = s1</b>" statement uses the default assignment overload.  When you run
it, you get an error, which happens for the following reason:

<OL>
<LI> <b>s2</b> is a copy of <b>s1</b>, which means that <b>s2.top</b> equals <b>s1.top</b>.
<LI> <b>s1.Clear()</b> is called, which means that <b>s1.top</b> is deleted.
<LI> When <b>s2.Pop()</b> is called, it uses <b>s2.top</b>, which is no longer a valid
     pointer.  This is when you get the error.
</OL>

<pre>
UNIX> <font color=darkred><b>make bin/stack_overload_naoc</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/stack_overload_naoc.o src/stack_overload_naoc.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/stack_no_ao_or_cc.o src/stack_no_ao_or_cc.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/stack_overload_naoc obj/stack_overload_naoc.o obj/stack_no_ao_or_cc.o
UNIX> <font color=darkred><b>bin/stack_overload_naoc < txt/input.txt</b></font>
stack_overload_naoc(85803,0x7fff7ea10000) malloc: *** error for object 0x7fe91ac03530: pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug
Abort
UNIX> <font color=darkred><b></b></font>
</pre>

In <b><a href=src/stack.cpp>src/stack.cpp</a></b>, we implement the assignment overload.
As the comment says, it's a little tricky -- what we do is make a temporary stack, which 
contains the original stack in reverse order.  Then we pop all of the nodes off the
temporary stack, which copies them in their original order:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* The assignment overload is tricky.  Since we can only traverse the stack
   from top to bottom, what we do is create a temporary stack, which has nodes in 
   reverse order, and then we pop all of its nodes, and push them onto our
   returning stack. */</font>

Stack& Stack::operator= (const Stack &s)
{
  Stack tmp;
  Stacknode *sn;

  <font color=blue>/* We need to set these, because the regular constructor is not called, so their
     values are uninitialized.  This is a hard bug to find, btw. */</font>

  size = 0;
  top = NULL;

  for (sn = s.top; sn != NULL; sn = sn-&gt;next) tmp.Push(sn-&gt;s);
  while (!tmp.Empty()) Push(tmp.Pop());
  return *this;
}
</pre></td></table></center><p>

Now, <b>bin/stack_overload</b> works properly:

<pre>
UNIX> <font color=darkred><b>make bin/stack_overload</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/stack_overload.o src/stack_overload.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/stack.o src/stack.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/stack_overload obj/stack_overload.o obj/stack.o
UNIX> <font color=darkred><b>head -n 5 txt/input.txt | bin/stack_overload </b></font>
 4  Tristan Tristan Hieratic
 3  Oliver Andrew Propagandist
 2  Joshua Classroom
 1  Tristan Passenger
 0  John Eighth
UNIX> <font color=darkred><b></b></font>
</pre>

This implementation is inefficient, because it calls all of those methods.
Like the implementation of <b>Clear()</b>, I could implement the assignment overload
without calling any methods, and make it more efficient.  I'm not going to do that here,
because I think this lecture is complicated enough;  however, put it in the back of your
mind.
<p>
I implement the copy constructor by simply calling the assignment overload:

<p><center><table border=3 cellpadding=3><td><pre>
Stack::Stack(const Stack &s)
{
  *this = s;
}
</pre></td></table></center><p>

To test it, take a look at
<b><a href=src/stack_copy.cpp>src/stack_copy.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include "stack.hpp"
#include &lt;iostream&gt;
using namespace std;

<font color=blue>/* This program demonstrates the copy constructor in action. */</font>

void Print_Stack(Stack st)
{
  while (!st.Empty()) cout &lt;&lt; st.Pop() &lt;&lt; endl;
  cout &lt;&lt; endl;
}

int main()
{
  string s;
  Stack st;

  <font color=blue>/* Create a stack from the lines of standard input. */</font>

  while (getline(cin, s)) st.Push(s);

  <font color=blue>/* Print it twice, using a procedure, which calls the copy constructor twice. */</font>

  Print_Stack(st);
  Print_Stack(st);
  return 0;
}
</pre></td></table></center><p>

When we run it, you see that it does indeed print the stack twice, so the copy constructor 
is in working order:

<pre>
UNIX> <font color=darkred><b>make bin/stack_copy</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/stack_copy.o src/stack_copy.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/stack.o src/stack.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/stack_copy obj/stack_copy.o obj/stack.o
UNIX> <font color=darkred><b>head -n 5 txt/input.txt | bin/stack_copy</b></font>
 4  Tristan Tristan Hieratic
 3  Oliver Andrew Propagandist
 2  Joshua Classroom
 1  Tristan Passenger
 0  John Eighth

 4  Tristan Tristan Hieratic
 3  Oliver Andrew Propagandist
 2  Joshua Classroom
 1  Tristan Passenger
 0  John Eighth

UNIX> <font color=darkred><b></b></font>
</pre>


<hr>
<h2>Queues</h2>

If any of that Stack description was unclear to you, go over it again.  If it's
still unclear, ask me about it in class, or ask your TA about it during their office
hours.  I know I'm repeating myself -- <i>this is fundamental material, and you need to 
understand it before proceeding</i>.
<p>
A queue is a FIFO data structure: first-in, first-out.  It can be used to mimic lines at
the grocery store, or cars waiting at a traffic light.  The <b>Queue</b> API 
(in <b><a href=include/queue.hpp>include/queue.hpp</a></b>)
is pretty 
much identical to the <b>Stack</b> API. It works differently, though, because 
<b>Pop()</b> now removes the oldest element
of the queue, rather than the newest.

<p><center><table border=3 cellpadding=3><td><pre>
#pragma once
#include &lt;string&gt;

<font color=blue>/* This defines the nodes of the queue.  It's only used internally to
   the queue, but we have to define it here.  */</font>

class Qnode {
  public:
    std::string s;
    Qnode *ptr;
};

<font color=blue>/* Here's the Queue class. */</font>

class Queue {
  public:

    <font color=blue>/* Constructors, Destructor, Assignment Overload */</font>

    Queue();
    Queue(const Queue &q);
    Queue& operator= (const Queue &q);
    ~Queue();

    <font color=blue>/* Same operators as stacks. */</font>

    void Clear();
    bool Empty() const;
    size_t Size() const;

    <font color=blue>/* Push puts the string on the end of the queue, 
       and Pop removes the string from the beginning of the queue. */</font>

    void Push(const std::string &s);
    std::string Pop();

  protected:
    Qnode *first;           <font color=blue>// Pointer to the first node on the queue.</font>
    Qnode *last;            <font color=blue>// Pointer to the last node on the queue.</font>
    int size;               <font color=blue>// The queue's size.</font>
};
</pre></td></table></center><p>
The <b>protected</b> data is different, too.  Now you are going to keep a pointer to the
first and last nodes on the queue.  If the queue is empty, then both will be <b>NULL</b>.
<p>
Each <b>Qnode</b> has a pointer called <b>ptr</b>, 
which points to the <i>previous</i> node on the queue.
The anology here is that if you are in line, you point to the person <i>behind</i> you, not the
person in front of you.  The reason is that this way you can insert new nodes behind the
last one, and you can delete the first node.
<p>
Let's take an example like the stack example:

<p><center><table border=3 cellpadding=3><td><pre>
Queue q;

q.Push("Give");
q.Push("Him");
q.Push("Six");
</pre></td></table></center><p>

This is going to result in the following layout of data:

<p><center><table border=0><td><img src=jpg/Queue-1.jpg></td></table></center><p>

Let's first consider calling <b>Pop()</b>.  The code is nearly exactly like the stack
code, only we are removing the <b>first</b> node rather than the <b>top</b> node,
and we have to put some extra code in to handle popping the last node on a queue.
The code is in 

<b><a href=src/queue.cpp>src/queue.cpp</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* Pop is actually very similar to the stack code.  
   You save the first string, save a pointer to the first node, 
   set "first" to point to the next node, and delete the first node. */</font>

string Queue::Pop()
{
  Qnode *oldfirst;
  string rv;

  if (size == 0) throw((string) "Queue::Pop() called on an empty queue");

  <font color=blue>/* Move "first" to point to the next node, store the return value, and
    delete the previous first node. */</font>

  rv = first-&gt;s;
  oldfirst = first;            
  first = oldfirst-&gt;ptr;
  delete oldfirst;

  <font color=blue>/* Handle the empty queue. */</font>

  if (first == NULL) last = NULL;

  <font color=blue>/* Update size and return. */</font>

  size--;
  return rv;
}
</pre></td></table></center><p>

As with the stack code, we'll go over an example step by step:

<p><center><table border=3 cellpadding=3><tr><td><img src=jpg/Queue-2.jpg></td><tr>
<tr><td><img src=jpg/Queue-3.jpg></td><tr>
<tr><td><img src=jpg/Queue-4.jpg></td><tr></table></center><p>

<b>Pop()</b> then returns "Give", its local variables go away, and then resulting Queue is:

<p><center><table border=0><td><img src=jpg/Queue-5.jpg></td></table></center><p>

The code for <b>Push()</b> is quite different from the stack code.  As before, we
create a new node with <b>new</b> and set its string.  However, we differ by setting
the new node's <b>ptr</b> to NULL.  Then we have to do two
different things depending on whether the queue was previously empty.  If it was empty,
then we set <b>first</b> and <b>last</b> to the new node.  Otherwise, we set
the <b>last</b> element's <b>ptr</b> to the new node, and then set <b>last</b> to be
the new node.  In that way, the new node
goes after the <b>last</b> element.  Here is the code:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* Push() creates a new node and then puts it at the end of the queue, 
   by having the last node point to it.  We need special case
   code for when the queue is empty. */</font>

void Queue::Push(const string &s)
{
  Qnode *newnode;

  newnode = new Qnode;      <font color=blue>// Create the new node. </font>
  newnode-&gt;s = s;
  newnode-&gt;ptr = NULL;

  if (last == NULL) {       <font color=blue>// If the queue is empty, set first to be this new node. </font>
    first = newnode;  
  } else {                  <font color=blue>// If the queue is non-empty, set the pointer of the last node to be this new node. </font>
    last-&gt;ptr = newnode; 
  }

  last = newnode;           <font color=blue>// Finally, set last to point to the new node, and increment size.</font>
  size++;
}
</pre></td></table></center><p>
<p>
Below is an example of calling <b>Push("Now")</b> on the two element list above:

<p><center><table border=3 cellpadding=3><tr><td><img src=jpg/Queue-6.jpg></td><tr>
<tr><td><img src=jpg/Queue-7.jpg></td><tr>
<tr><td><img src=jpg/Queue-8.jpg></td><tr></table></center><p>

When it returns, <b>newnode</b> goes away, and the resulting queue is:

<p><center><table border=0><td><img src=jpg/Queue-9.jpg></td></table></center><p>

<b>Clear()</b>, <b>Empty()</b>, <b>Size()</b>, the regular constructor and the destructor
are all straightforward.  I'll visit the assignment overload and copy constructor below.
To test this, let's implement <b>tail</b> with a queue.  Go ahead and simply read the 
comments in <b><a href=src/queue_tail.cpp>src/queue_tail.cpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* This program implements tail using a queue.  It reads lines of standard input
   into the queue, and once the queue reaches ten elements in size, then every
   time a line is pushed onto the end of the queue, a line is popped off the front.
   At the end, the queue is printed. */</font>

#include "queue.hpp"
#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s;
  Queue q;

  <font color=blue>/* Read the lines into the queue, and keep it at a maximum of 10 elements. */</font>

  while (getline(cin, s)) {
    q.Push(s);
    if (q.Size() &gt; 10) (void) q.Pop();
  }

  <font color=blue>/* Print the queue. */</font>

  while (!q.Empty()) cout &lt;&lt; q.Pop() &lt;&lt; endl;
  return 0;
}
</pre></td></table></center><p>

As with <b>stack_rev.cpp</b>, this is a really straightfoward program, because the data structure
fits the task so nicely.  We can verify that it works, both when it receives more than ten lines,
and less:

<pre>
UNIX> <font color=darkred><b>make clean</b></font>
rm -f obj/* bin/*
UNIX> <font color=darkred><b>make bin/queue_tail</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/queue_tail.o src/queue_tail.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/queue.o src/queue.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/queue_tail obj/queue_tail.o obj/queue.o
UNIX> <font color=darkred><b>wc txt/input.txt</b></font>
      20      63     423 txt/input.txt
UNIX> <font color=darkred><b>tail txt/input.txt</b></font>
10  Brayden Clarinet
11  Nicholas Casteth
12  Hunter Hart
13  Ellie Bangle
14  Addison Fracture
15  Ava Hereafter
16  Evelyn Kigali
17  Tristan Housewives
18  Jack Bodybuilder
19  Gabriel Millionth
UNIX> <font color=darkred><b>bin/queue_tail < txt/input.txt</b></font>
10  Brayden Clarinet
11  Nicholas Casteth
12  Hunter Hart
13  Ellie Bangle
14  Addison Fracture
15  Ava Hereafter
16  Evelyn Kigali
17  Tristan Housewives
18  Jack Bodybuilder
19  Gabriel Millionth
UNIX> <font color=darkred><b>head -n 3 txt/input.txt</b></font>
 0  John Eighth
 1  Tristan Passenger
 2  Joshua Classroom
UNIX> <font color=darkred><b>head -n 3 txt/input.txt | bin/queue_tail </b></font>
 0  John Eighth
 1  Tristan Passenger
 2  Joshua Classroom
UNIX> <font color=darkred><b></b></font>
</pre>

As with the Stack data structure, we need to implement a copy constructor and assignment
overload.  This one is more simple, because you can simply Push() each node on the queue,
from front to back.
Here's the code:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* The assignment overload traverses the nodes and pushes each one. */</font>

Queue& Queue::operator= (const Queue &q)
{
  Qnode *tmp;

  Clear();
  for (tmp = q.first; tmp != NULL; tmp = tmp-&gt;ptr) Push(tmp-&gt;s);
  return *this;
}

<font color=blue>/* The copy constructor calls the assignment overload. */</font>

Queue::Queue(const Queue &q)
{
  *this = q;
}
</pre></td></table></center><p>

To test, the programs
<b><a href=src/queue_overload.cpp>src/queue_overload.cpp</a></b>
and 
<b><a href=src/queue_copy.cpp>src/queue_copy.cpp</a></b> work just like their stack counterparts.
<b><a href=src/queue_overload.cpp>src/queue_overload.cpp</a></b> reads standard input into a 
queue, assigns a second queue to equal the first, clears the first and then prints the second.
If correct, standard input should equal standard output:

<pre>
UNIX> <font color=darkred><b>cat txt/input.txt | openssl md5</b></font>
(stdin)= 5fddce6788199e7a51227f78a9f3bb4f
UNIX> <font color=darkred><b>bin/queue_overload < txt/input.txt | openssl md5</b></font>
(stdin)= 5fddce6788199e7a51227f78a9f3bb4f
UNIX> <font color=darkred><b></b></font>
</pre>

<b><a href=src/queue_copy.cpp>src/queue_copy.cpp</a></b> calls a procedure to print the queue,
which makes a copy.  It does it twice, so you should see the input twice (with an extra newline
at the end):

<pre>
UNIX> <font color=darkred><b>head -n 2 txt/input.txt</b></font>
 0  John Eighth
 1  Tristan Passenger
UNIX> <font color=darkred><b>head -n 2 txt/input.txt | bin/queue_copy </b></font>
 0  John Eighth
 1  Tristan Passenger

 0  John Eighth
 1  Tristan Passenger

UNIX> <font color=darkred><b></b></font>
</pre>


<hr>
<h2>Doubly-Linked Lists</h2>

The most general-purpose list data structure is the doubly linked list.  
It is how the <b>list</b> part of the STL is implemented.  The nice features
of doubly-linked lists are that they may be traversed in the forward and reverse
direction, they allow for arbitrary insertion of nodes <i>anywhere</i> in the list,
and they allow for arbitrary deletion of <i>any</i> nodes.  Our API for 
the doubly linked list is in 
<b><a href=include/dlist.hpp>include/dlist.hpp</a></b>:

<p><center><table border=3 cellpadding=3><td><pre>
#pragma once
#include &lt;string&gt;

class Dnode {
  public:
    std::string s;
    Dnode *flink;
    Dnode *blink;
};

class Dlist {
  public:

    <font color=blue>/* Constructors, Destructor, Assignment Overload */</font>

    Dlist();
    Dlist(const Dlist &d);
    Dlist& operator= (const Dlist &d);
    ~Dlist();

    void Clear();          <font color=blue>// This should not delete the sentinel node.</font>
    bool Empty() const;
    size_t Size() const;

    <font color=blue>/* Put new strings on the front or back of the list */</font>

    void Push_Front(const std::string &s);
    void Push_Back(const std::string &s);

    <font color=blue>/* Remove and return the first or last element of the list */</font>

    std::string Pop_Front();
    std::string Pop_Back();

    Dnode *Begin() const;         <font color=blue>// Pointer to the first node on the list </font>
    Dnode *End() const;           <font color=blue>// Pointer to "one past" the last node on the list.</font>
    Dnode *Rbegin() const;        <font color=blue>// Pointer to the last node on the list</font>
    Dnode *Rend() const;          <font color=blue>// Pointer to "one before" the first node on the list.</font>

    void Insert_Before(const std::string &s, Dnode *n);
    void Insert_After(const std::string &s, Dnode *n);
    void Erase(Dnode *n);

  protected:
    Dnode *sentinel;
    size_t size;
};
</pre></td></table></center><p>


All of these methods should be familiar to you, as they are analogous to STL
methods.  There are two simple implementations of reversing standard input in
<b><a href=src/dlist_rev_1.cpp>src/dlist_rev_1.cpp</a></b> and
<b><a href=src/dlist_rev_2.cpp>src/dlist_rev_2.cpp</a></b>.
The first works by calling
<b>Push_Back()</b> and <b>Pop_Back()</b>, and the second works by calling 
<b>Push_Front()</b> and <b>Pop_Front()</b>.   
<p>
A little more subtle is 
<b><a href=src/dlist_rev_3.cpp>src/dlist_rev_3.cpp</a></b>,
which creates the list 
using <b>Push_Front()</b>, and then traverses it using <b>Begin()</b> and
<b>End()</b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include "dlist.hpp"
#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s;
  Dlist l;
  Dnode *d;

  while (getline(cin, s)) l.Push_Front(s);
  for (d = l.Begin(); d != l.End(); d = d-&gt;flink) cout &lt;&lt; d-&gt;s &lt;&lt; endl;
  return 0;
}
</pre></td></table></center><p>

That <b>for</b> loop looks very STL-like, except <b>Begin()</b> and <b>End()</b> don't
return iterators.  They return a pointer to the list node, which contains three fields:
<p>
<UL>
<LI> The string <b>s</b>.
<LI> A pointer to the next node on the list: <b>flink</b> (forward link).
<LI> A pointer to the previous node on the list: <b>blink</b> (backward link).
</UL>

The <b>Begin()</b> method returns a pointer to the first node on the list, and
<b>End()</b> returns a pointer to one element past the last node on the list.  That's
just like the STL.  To move from one node to the next, though, we use <b>d->flink</b>.
That's because I find operator overloading odious, and I don't want to overload
the <b>++</b> operator.

<p>
In a similar manner, in 
<b><a href=src/dlist_rev_4.cpp>src/dlist_rev_4.cpp</a></b>, 
the list is created with <b>Push_Back()</b>,
and we traverse it from back to front using <b>Rbegin()</b>, <b>Rend()</b> and <b>d->blink</b>:

<p><center><table border=3 cellpadding=3><td><pre>
#include "dlist.hpp"
#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s;
  Dlist l;
  Dnode *d;

  while (getline(cin, s)) l.Push_Back(s);
  for (d = l.Rbegin(); d != l.Rend(); d = d-&gt;blink) cout &lt;&lt; d-&gt;s &lt;&lt; endl;
  return 0;
}
</pre></td></table></center><p>

Alternatively, in 
<b><a href=src/dlist_rev_5.cpp>src/dlist_rev_5.cpp</a></b>, 
we create the list with <b>Push_Front()</b>
and print it by repeatedly printing the first element and then erasing it:

<p><center><table border=3 cellpadding=3><td><pre>
#include "dlist.hpp"
#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s;
  Dlist l;

  while (getline(cin, s)) l.Push_Front(s);
  while (!l.Empty()) {
    cout &lt;&lt; l.Begin()-&gt;s &lt;&lt; endl;
    l.Erase(l.Begin());
  }
  return 0;
}
</pre></td></table></center><p>

And finally, in 
<b><a href=src/dlist_rev_6.cpp>src/dlist_rev_6.cpp</a></b>,
, we use the <b>Insert_Before()</b> 
method, which inserts a new node before the given node, to create the list in a manner
equivalent to <b>Push_Back()</b>.  We do this by inserting before <b>End()</b>.
We then traverse the list from back to front.

<p><center><table border=3 cellpadding=3><td><pre>
#include "dlist.hpp"
#include &lt;iostream&gt;
using namespace std;

int main()
{
  string s;
  Dlist l;
  Dnode *d;

  while (getline(cin, s)) l.Insert_Before(s, l.End());
  for (d = l.Rbegin(); d != l.Rend(); d = d-&gt;blink) {
    cout &lt;&lt; d-&gt;s &lt;&lt; endl;
  }
  return 0;
}
</pre></td></table></center><p>
<hr>

<h2>Circular Lists with a Sentinel</h2>

I'm not going to implement <b>src/dlist.cpp</b> for you.  That's your job in lab.
However, I will outline the structure, which may seem convoluted at first, but
will seem elegant and beautiful by the time you're done with it.
<p>
We are going to have our lists contain a <i><b>sentinel</b></i> node.  This is an extra
node which begins each list.  So, if a list contains <i>size</i> elements, then 
it will contain <i>size+1</i> nodes.
<p>
Secondly, our list is going to be <i><b>circular</b></i>.  This means that the <b>flink</b>
field of the last node in the list points to the sentinel, and the <b>blink</b> field of the
first node also points to the sentinel.  This may seem confusing, so let's look at an 
example.  Suppose we do:

<p><center><table border=3 cellpadding=3><td><pre>
Dlist l;

l.Push_Back("Give");
l.Push_Back("Him");
l.Push_Back("Six");
</pre></td></table></center><p>

Then our list looks as follows:

<p><center><table border=0><td><img src=jpg/List-1.jpg></td></table></center><p>

Think about traversing such a list.  Typically, a student's first response to this
structure is, "How do I keep from getting into an infinite loop when I'm traversing?"
The answer is that you end when you reach the sentinel node.  Consider the loop 
from 
<b><a href=src/dlist_rev_3.cpp>src/dlist_rev_3.cpp</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
  for (d = l.Begin(); d != l.End(); d = d-&gt;flink) cout &lt;&lt; d-&gt;s &lt;&lt; endl;
</pre></td></table></center><p>

<b>l.Begin()</b> is going to return <b>sentinel->flink</b>, and <b>l.End()</b> is going
to return <b>sentinel</b>.  Thus, executing this loop on the list above will indeed
print out "Give", then "Him", and then "Six".  At the next iteration of the loop, 
the pointer <b>d</b> will be pointing to the sentinel, and the loop will end.
<p>
Study that code and the picture above until you understand it.
<p>
When the constructor for a list is called, it is going to allocate a sentinel node
and have its <b>flink</b> and <b>blink</b> pointers point to itself:


<p><center><table border=0><td><img src=jpg/List-2.jpg></td></table></center><p>

That means you are going to have to call <b>new</b> in the constructor.  Consider
the previous <b>for</b> loop executing on the empty list.  Since <b>sentinel->flink</b> 
is equal to <b>sentinel</b>, the body of the loop is never executed.  That's just what
you want!

<hr>
<h2>Insertion</h2>

Suppose I want to insert a new node before a given node in the list.  For example:

<p><center><table border=3 cellpadding=3><td><pre>
Dlist l;
Dnode *d;

l.Push_Back("Give");
l.Push_Back("Six");
d = l.Begin();
d = d->flink;
l.Insert_Before("Him", d);
</pre></td></table></center><p>

At the point of the <b>Insert_Before()</b> statement, here's the state of the program:

<p><center><table border=0><td><img src=jpg/List-3.jpg></td></table></center><p>

In <b>Insert_Before()</b>, we'll have two <b>(Dnode *)</b>'s called <b>prev</b> and <b>newnode</b>.
We'll set <b>prev</b> to <b>d->blink</b> and set <b>newnode</b> equal to a newly allocated
<b>Dnode</b> with the proper string:

<p><center><table border=0><td><img src=jpg/List-4.jpg></td></table></center><p>

Now we can hook <b>newnode</b> into the list by appropriately setting its <b>flink</b> and
<b>blink</b> pointers, and by appropriately setting <b>prev->flink</b> and <b>d->blink</b>.
When we're done, the new node is hooked into the list:

<p><center><table border=0><td><img src=jpg/List-5.jpg></td></table></center><p>

<b>Insert_Before()</b> returns to the caller, which means that <b>newnode</b> and <b>prev</b>
go away, and the list is as we want it:

<p><center><table border=0><td><img src=jpg/List-6.jpg></td></table></center><p>

Since the list is circular, you can insert new nodes between the sentinel and the last node
on the list.  What will that do?  That will effect <b>Push_Back()</b>!  In fact, you can 
implement each of <b>Push_Back()</b>, <b>Push_Front()</b>, and <b>Insert_After</b> with 
<b>Insert_Before()</b>.  Isn't that convenient.

<hr>
<h2>Deletion</h2>

First, you should never allow deletion of the sentinel.  If you do, you'll be in a world
of hurt...  Deleting other nodes is a straightforward affair, much like insertion.  
Consider the following code:

<p><center><table border=3 cellpadding=3><td><pre>
Dlist l;
Dnode *d;

l.Push_Back("Give");
l.Push_Back("Him");
l.Push_Back("Six");
d = l.Begin();
d = d->flink;
l.Erase(d);
</pre></td></table></center><p>

At the point of the <b>Erase()</b> call, the state of the program is:

<p><center><table border=0><td><img src=jpg/List-7.jpg></td></table></center><p>

As before, in <b>Erase()</b>, we'll have two <b>(Dnode *)</b>'s, this time
called <b>prev</b> and <b>next</b>.  We set them to the two nodes surrounding
<b>d</b>:

<p><center><table border=0><td><img src=jpg/List-8.jpg></td></table></center><p>

We can then remove <b>d</b> from the list by setting <b>next</b>'s <b>blink</b>
pointer and <b>prev</b>'s <b>flink</b> pointer:

<p><center><table border=0><td><img src=jpg/List-9.jpg></td></table></center><p>

And calling delete on <b>d</b> (and decrementing <b>size</b>):

<p><center><table border=0><td><img src=jpg/List-A.jpg></td></table></center><p>

When <b>Erase()</b> returns, the node is gone, as are <b>prev</b> and <b>next</b>.
The variable <b>d</b> is now pointing to deleted memory, you should should take care
not to use it.

<p><center><table border=0><td><img src=jpg/List-B.jpg></td></table></center><p>

As with <b>Insert_Before()</b>, you can use <b>Erase()</b> to implement other
methods like <b>Pop_Back()</b> and <b>Pop_Front()</b>.  

<hr>
<h2>Clear, The destructor, The assignment overload and the copy constructor</h2>

<b>Clear()</b> is a little different from the stack and queue versions.  The reason is
that <b>Clear()</b> should erase all nodes <i>but the sentinel</i>.  That means that the
destructor needs to do more than just call <b>Clear()</b> -- it will have to delete the
sentinel, too.

<p>
The assignment overload and copy constructor may call <b>Push_Back()</b>, so they will
be simple to implement.
