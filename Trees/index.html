
<title>CS140 Lecture Notes - Basic Trees & Binary Search Trees</title>
<h2>CS140 Lecture Notes - Basic Trees & Binary Search Trees</h2>
<UL>
<LI> James S. Plank
<LI> Directory: <b>/home/plank/cs140/Notes/Trees</b>
<LI> Original notes: 2005.
<LI> Last Revision: <i>
Sat Nov  2 19:12:27 EDT 2019
</i>
</UL>

<hr>
Topcoder problems that are good for trees:
<UL>
<LI> <a href=http://web.eecs.utk.edu/~jplank/topcoder-writeups/2016/TreeAndVertex/index.html>Tree And Vertex</a>: Count edges in a tree (D2, 250).
<LI> <a href=http://web.eecs.utk.edu/~jplank/plank/classes/cs140/Notes/FiringEmployees/index.html>Firing Employees</a>: A nice straightforward post-order traversal (D1, 250).
</UL>

<hr>
A tree is a basic linked data structure  that is richer than a list.
For tree basics, please read the following parts of 
<a href=http://en.wikipedia.org/wiki/Tree_(data_structure)>the Wikipedia page on trees</a>:
<p>
<UL>
<LI> The first sentence.  Maybe.  You can just look at the 
picture to the right, and then skip straight to the <b>Terminology</b> section.
Sometimes it seems like the people who write wikipedia pages have nothing to do but try to confuse their readers 
with pedantic definitions for the sake of completeness.  Clearly, they do not
teach CS140 or its ilk, or if they do, I'd try to take it from another university.
 I guess you get what you pay for.
<LI> The <b>Terminology</b> section.
<LI> The <b>Traversal Methods</b> section.
</UL>
<p>
Trees are often a very natural way to represent hierarchies.  For example, the mathematical
expression:
<center>
<i>(5a + 10b) / (14a<sup>4</sup> - 28b)</i>
</center>
is very clearly represented by the following tree:

<p><center><table border=0><td><img src=jpg/Arith-Tree.jpg width=450></td></table></center><p>

Using tree terminology, the external, (or leaf) 
nodes are either variables or values, and the 
internal nodes are operators.  

<hr>
<h3>Tree Traversals</h3>

We typically talk about three tree traversal methods:

<p>
<center>
<table border=3>
<td valign=top>
<h3>Pre-Order</h3>
<hr>
<b>To visit a node:</b><br>
<UL>
<LI> Perform an action (like Print)
<LI> Recursively visit children in order.
</UL>
<hr>
<b>Example on the above tree:</b><br>
Print "/"<br>
Print "+"<br>
Print "*"<br>
Print "5"<br>
Print "a"<br>
Print "*"<br>
Print "10"<br>
Print "b"<br>
Print "-"<br>
Print "*"<br>
Print "14"<br>
Print "exp"<br>
Print "a"<br>
Print "4"<br>
Print "*"<br>
Print "28"<br>
Print "b"<br>
</td>
<td valign=top>
<h3>Post-Order</h3>
<hr>
<b>To visit a node:</b><br>
<UL>
<LI> Recursively visit children in order.
<LI> Perform an action
</UL>
<hr>
<b>Example on the above tree:</b><br>
Print "5"<br>
Print "a"<br>
Print "*"<br>
Print "10"<br>
Print "b"<br>
Print "*"<br>
Print "+"<br>
Print "14"<br>
Print "a"<br>
Print "4"<br>
Print "exp"<br>
Print "*"<br>
Print "28"<br>
Print "b"<br>
Print "*"<br>
Print "-"<br>
Print "/"<br>
</td>
<td valign=top>
<h3>In-Order (Binary only)</h3>
<hr>
<b>To visit a node:</b><br>
<UL>
<LI> Recursively visit left child.
<LI> Perform an action
<LI> Recursively visit right child.
</UL>
<hr>
<b>Example on the above tree:</b><br>
Print "5"<br>
Print "*"<br>
Print "a"<br>
Print "+"<br>
Print "10"<br>
Print "*"<br>
Print "b"<br>
Print "/"<br>
Print "14"<br>
Print "*"<br>
Print "a"<br>
Print "exp"<br>
Print "4"<br>
Print "-"<br>
Print "28"<br>
Print "*"<br>
Print "b"<br>
</td>
</table>
</center>
<p>

<b>Example Question:</b> "Which of the above traversals would allow you to 
evaluate the expression of the above tree?"  
<p>
<b>Answer</b>: A post-order traversal -- for each operator in an internal
node, you need to first evaluate each of its children before you can 
perform the operation.
For example, you need to evaluate the left
subtree of "/" and then the right subtree before you divide the
two answers to get the final evaluation of the expression.

<hr>
<h3>Binary Search Trees</h3>

Binary search trees are an exceptionally important type of tree.  As 
their name implies, they are binary trees, where each node has a value,
a left child and a right child.  The important property of a binary
search tree is the following:
<p>
<UL>
<LI> If a node has a left child, then the left child is the root of a
binary search tree whose maximum value is less than or equal to the
node's value.
<LI> If a node has a right child, then the right child is the root of a
binary search tree whose minimum value is greater than or equal to the
node's value.
</UL>
<p>

Here are some examples of binary search trees that hold strings:

<p><center><table border=3 cellpadding=4>
<td><img src=jpg/BST-1.jpg align=center valign=center width=50></td>
<td><img src=jpg/BST-2.jpg align=center valign=center width=150></td>
<td><img src=jpg/BST-3.jpg align=center valign=center width=150></td>
<td><img src=jpg/BST-4.jpg align=center valign=center width=180></td>
</table></center><p>

As demonstrated by the second two trees above, there can be more than one
binary search tree that corresponds to the same data.
<p>
Here are two examples of trees that are not binary search trees:

<p><center><table border=3 cellpadding=4>
<td align=center><img src=jpg/NBST-1.jpg align=center valign=center width=230><hr>
<i>Daisy</i>, <i>Luigi</i> and <i>Luther</i> are all greater than <i>Binky</i>.</td>
<td align=center><img src=jpg/NBST-2.jpg align=center valign=center width=230><hr>
The tree is not binary.</td>
</table></center><p>

Binary search trees have nice properties.  For example, you can sort the
data by performing an in-order traversal.  You can also find a piece of
data simply by traversing a single path from the root to the data, or
to where the data would be.  For example, in the tree:

<p><center><table border=0><td><img src=jpg/BST-4.jpg width=180></td></table></center><p>

If I want to find <i>Luigi</i>, what I do is start at the root of the tree,
and compare it to <i>Luigi.</i>  If it equals <i>Luigi</i>, then I'm done.  
If not, and <i>Luigi</i> is less than the node's value, then I recursively
continue the process on the tree's left child.
If <i>Luigi</i> is greater than the node's value, then I instead recursively
continue the process on the tree's right child.  If I ever get to a point
where the node has no child for me to search on, I can conclude that the
value is not in the tree.  
<p>
Continuing the example of finding <i>Luigi</i>, I would:
<p>
<UL>
<LI> I start at <i>Binky.</i>  Since <i>Luigi</i> is greater than <i>Binky</i>, I'll continue
searching on <i>Binky</i>'s right child.
<LI> I'm next at <i>Fred</i>.  Again, <i>Luigi</i> is greater than <i>Fred</i>, so 
I continue searching on <i>Fred</i>'s right child.
<LI> Now I'm at <i>Luther</i>.  <i>Luigi</i> is less than <i>Luther</i>, so 
I continue searching on <i>Luther</i>'s left child.
<LI> I have found <i>Luigi.</i>
</UL>
Similarly, suppose I try to find <i>Calista</i>:
<UL>
<LI> I start at <i>Binky.</i>  Since <i>Calista</i> is greater than <i>Binky</i>, I'll continue
searching on <i>Binky</i>'s right child.
<LI> I'm next at <i>Fred</i>.  <i>Calista</i> is less than <i>Fred</i>, so 
I continue searching on <i>Fred</i>'s left child.
<LI> Now I'm at <i>Daisy</i>.  <i>Calista</i> is less than <i>Daisy</i>, so 
I continue searching on <i>Daisy</i>'s left child. 
<LI> However, <i>Daisy</i> has no left child.  I can conclude that <i>Calista</i>
is not in the search tree.
</UL>

<hr>
<h3>Binary Search Tree Operations: Find, Insert, Delete</h3>

I have just described how to find a value in a binary search tree.  
Insertion is a pretty simple matter too.  To insert a value <b>s</b>, 
assume that <b>s</b> is not in the tree, and find where <b>s</b> should be.
Create the node and put it there.
<p>
For example, suppose that we want to insert <i>Calista</i> into the above tree. 
We try to find the string as we did above.  
We fail at <i>Daisy</i>'s left child, which doesn't exist.
Therefore, we create a node for <i>Calista</i> and insert it as <i>Daisy</i>'s 
left child:

<p><center><table border=0><td><img src=jpg/BST-5.jpg width=200></td></table></center><p>

To insert duplicate values, do the same procedure, only if you find the 
value, you continue searching either on the left or the right child, as 
if you didn't find the key.
For example, if you wanted to insert <i>Binky</i> into the tree again, 
you would either put it as <i>Binky</i>'s left child or <i>Calista</i>'s left child:

<p><center><table border=3 cellpadding=4><td><img src=jpg/BST-6.jpg width=200></td>
<td><img src=jpg/BST-7.jpg width=240></td></table></center><p>

Deletion is the trickiest.  To delete a node, you must consider three cases.  Let's
consider the tree below as an example:

<p><center><table border=0><td><img src=jpg/BST-5.jpg width=200></td></table></center><p>

<b>Case 1</b>: The node has no children (it's a leaf node).  You can simply
delete it.  I won't draw an example, but you should see very easily that deleting
<i>Calista</i>, <i>Luigi</i> or <i>Waluigi</i> just removes them from the tree.
<p>
<b>Case 2</b>: The node has just one child.  To delete the node, replace it
with that child.  I draw two examples below:


<p><center><table border=3 cellpadding=4>
<td align=center><img src=jpg/BST-8.jpg align=center valign=center width=200><hr>
After deleting <i>Binky</i>.</td>
<td align=center><img src=jpg/BST-9.jpg align=center valign=center width=150><hr>
After deleting <i>Daisy</i>.</td>
</table></center><p>

<b>Case 3</b>: The node has two children.  In this case, you find the node
in the tree whose value is the greatest value less than (or equal to) the node's
value.  That will be the rightmost node in the subtree rooted by the left child.
That node will not have a right child.  First, delete it.  Then use it to replace
the node that you are deleting.
<p>
Alternatively, you can replace it with the leftmost node in the tree rooted by 
the node's right child.  Both will work.
<p>
For example, let's delete <i>Fred</i> from the tree below:
<p><center><table border=0><td><img src=jpg/BST-A.jpg width=250></td></table></center><p>

Since <i>Fred</i> has two children, we find the rightmost node in the tree rooted
by <i>Fred</i>'s left child.  That is the node <i>Fiona</i>.  We first delete
<i>Fiona</i>:

<p><center><table border=0><td><img src=jpg/BST-B.jpg width=250></td></table></center><p>

And then we replace <i>Fred</i> with <i>Fiona</i>:

<p><center><table border=0><td><img src=jpg/BST-C.jpg width=250></td></table></center><p>

A second example is easier, but sometimes confusing -- suppose we want to delete <i>Luther</I>.
Since <i>Luther</i> has two children, we find the rightmost 
node in the tree rooted
by <i>Luther</i>'s left child.  Since there is only one node in that tree, that's the one we delete: <i>Luigi</i>.  We then replace <i>Luther</i> with <i>Luigi</i>:

<p><center><table border=0><td><img src=jpg/BST-D.jpg width=250></td></table></center><p>
<hr>
<h3>Implementation -- API and overview</h3>

The file 
<b><a href=include/bstree.hpp>include/bstree.hpp</a></b>
contains a simple binary search tree API.  Scan it quickly, but don't go into to much
detail.  I'll do that with you after the specification:

<p><center><table border=3 cellpadding=3><td><pre>
#include &lt;vector&gt;
#include &lt;string&gt;

namespace CS140 {

<font color=blue>/* These are the nodes of a tree. The keys are strings, and the vals are generic pointers.
   Please see the lecture notes for a more thorough explanation of what a (void *)</font> is. */</font>

class BSTNode {
  public:
    BSTNode *left;
    BSTNode *right;
    BSTNode *parent;
    std::string key;
    void *val;
};

class BSTree {
  public:

    <font color=blue>/* Constructor, copy constructor, assignment overlead, destructor.
       I am only implementing the constructor and destructor here in the notes.
       You will implement the other two in your lab. */</font>

    BSTree();
    BSTree(const BSTree &t);
    BSTree& operator= (const BSTree &t);
    ~BSTree();

    void Clear();                                      <font color=blue>// Turns the tree into an empty tree.</font>
 
    bool Insert(const std::string &key, void *val);    <font color=blue>// Insert the key and val.  Returns success (duplicates are not allowed.</font>
    void *Find(const std::string &key) const;          <font color=blue>// Return the val associated with the key.  Returns NULL if key not found.</font>
    bool Delete(const std::string &key);               <font color=blue>// Delete the node with the key.  Returns whether there was such a node.</font>

    void Print() const;                                <font color=blue>// These are obvious.</font>
    size_t Size() const;
    bool Empty() const;

    std::vector &lt;std::string&gt; Ordered_Keys() const;    <font color=blue>// Return a vector of sorted keys</font>
    std::vector &lt;void *&gt; Ordered_Vals() const;         <font color=blue>// Return a vector of the vals, sorted by the keys.</font>

    <font color=blue>/* You'll write these as part of your lab. */</font>

    int Depth(const std::string &key) const;           <font color=blue>// Distance from a node to the root.  Returns -1 if the key is not in the tree.</font>
    int Height() const;                                <font color=blue>// Returns the depth of the node with maximum depth, plus one.</font>

  protected:
    BSTNode *sentinel;                                 <font color=blue>// Like the dlists, there is a sentinel.  Its right points to the root.</font>
    size_t size;                                       <font color=blue>// Size of the tree</font>
   
    void recursive_inorder_print(int level, const BSTNode *n) const;          <font color=blue>// A helper for Print()</font>
    void recursive_destroy(BSTNode *n);                                       <font color=blue>// A helper for Clear()</font>
    void make_val_vector(const BSTNode *n, std::vector&lt;void *&gt; &v) const;     <font color=blue>// A helper for Ordered_Vals()</font>

    <font color=blue>/* You'll write these as part of your lab. */</font>

    int recursive_find_height(const BSTNode *n) const;                        <font color=blue>// A helper for Height()</font>
    void make_key_vector(const BSTNode *n, std::vector&lt;std::string&gt; &v) const; <font color=blue>// A helper for Ordered_Keys()</font>
    BSTNode *make_balanced_tree(const std::vector&lt;std::string&gt; &sorted_keys,   <font color=blue>// A helper for the copy constructor and assignment overload.</font>
                                const std::vector&lt;void *&gt; &vals,
                                size_t first_index,
                                size_t num_indices) const;
};

};
</pre></td></table></center><p>

First off, you'll note I'm using a "namespace".  It's about time that I introduce you to namespaces.
They are pretty simple -- when you define a class (or struct), global variable, or procedure within a 
namespace, then when someone else wants to use it, they need to either:

<UL>
<LI> State that they are using the namespace.
<LI> State that they are using the class, variable or procedure from the namespace.
<LI> Prepend the namespace and two colons whenever they use a class, variable or procedure.
</UL>

In this instance, I'm defining the classes <b>BSTNode</b> and <b>BSTree</b> within the namespace <b>CS140</b>.
If I want to use, for example, the <b>BSTree</b> class, then I must do one of the following:

<UL>
<LI> Put "using namespace CS140" at the top of my code.
<LI> Put "using CS140::BSTree" at the top of my code.
<LI> Use "CS140::BSTree" wherever I would normally just use "BSTree".
</UL>

For example, in 
<b><a href=src/bstree_tester.cpp>src/bstree_tester.cpp</a></b>, I say 
"using CS140::BSTree", and then when I declare pointers to the variables, I say

<p><center><table border=3 cellpadding=3><td><pre>
BSTree *t1, *t2, *tmp;
</pre></td></table></center><p>

If I didn't put the "using" statement in there, I'd have to declare the pointers as:

<p><center><table border=3 cellpadding=3><td><pre>
CS140::BSTree *t1, *t2, *tmp;
</pre></td></table></center><p>

Namespaces are nice because they help you avoid conflicts in naming.  I won't go 
crazy with them, but I do think they are something you should see an know about at
this point in your programming careers.
<p>
Now, the BSTree API is a little like the Dlist API in the previous lecture, with some extra bells
and whistles.  Let's first go over the methods:
<p>
<UL>
<LI> The constructor, destructor, and methods <b>Size()</b> and <b>Empty()</b> are
straightforward enough not to need explanation.
<p>
<LI> <b>Insert(key, val)</b> inserts the given key and val pair into the tree.  The
<b>val</b> is of type <b>(void *)</b>, which you probably haven't seen before.
It is used extensively in C (and I use it a lot in C++ too, but I suspect I'm in the minority).  
It is basically a catch-all that stands for "any pointer type."  
You can store any pointer into the tree by "casting" it to a <b>(void *)</b>.  For example,
let's suppose you have a pointer <b>p</b> that you have declared as:
<p>
<p><center><table border=3 cellpadding=3><td><pre>
Person *p;
</pre></td></table></center><p>

And suppose you want to insert the key "Fred" and the val <b>p</b> into a tree <b>t</b>.
Then you would do it as follows:

<p><center><table border=3 cellpadding=3><td><pre>
t.Insert("Fred", (void *) p);
</pre></td></table></center><p>

The "<b>(void *) p</b>" part tells the compiler "I know you want a <b>(void *)</b>
and I'm giving you a <b>(Person *)</b>.  It's all good."  If you don't put the 
"<b>(void *)</b>" in, the compiler will yell at you. 
<p>
We use the <b>(void *)</b> for flexibility -- it allows you to store any pointer in 
the <b>val</b> field.  The STL of course, does this in a different and more type-safe
way.  Using a <b>(void *)</b> is an "old school" C trick.
<p>
<b>Insert()</b> returns whether the key was inserted.  We're going to disallow
inserting duplicate keys, so <b>Insert()</b> will return <b>false</b> if it gets a duplicate key.

<p>
<LI> <b>Find(key)</b> returns the <b>val</b> associated with the key, if it's in the
tree.  The <b>val</b> is a <b>(void *)</b>, and to use it, you cast it back to a pointer
of the type that you inserted.   For example, if you inserted a <b>(Person *)</b> 
with the <b>Insert()</b> command above, you'd use <b>Find()</b> as follows:

<p><center><table border=3 cellpadding=3><td><pre>
p = (Person *) Find("Fred");
</pre></td></table></center><p>

If the key is not found, then <b>Find()</b> returns <b>NULL</b>.
Does that mean that you can't store <b>NULL</b> in the tree?  You tell me.

<p>
<LI> <b>Depth(key)</b> returns the distance that a key is from the root of the tree.
It returns -1 if the key is not in the tree.
<p>
<LI> <b>Height()</b> returns the depth of the ndoe with the maximum depth in the tree, plus 1.
An empty tree has a height of zero.  A tree with one node has a height of one.
<p>
<LI> <b>Delete(key)</b> deletes the node with the given key.  It returns <b>true</b> or
<b>false</b>, depending on whether the key was in the tree.
<p>
<LI> <b>Print()</b> prints all the keys by using a reverse inorder traversal.  Each key is
preceded by two spaces times the key's depth in the tree so that you can see the structure
of the tree.  I'll go over these calls in the examples below.
<p>
<LI> <b>Ordered_Keys()</b> returns a sorted vector of the keys in the tree.
<p>
<LI> <b>Ordered_Vals()</b> returns a vector of the vals in the tree, in the same order as
<b>Ordered_Keys()</b>.
<p>
<LI> The copy constructor and assignment overload are special.  Not only do they make a copy
     of the tree, but the copy will be <i>balanced</i>.  In other words, the middle key will
     be the root of the tree.  The middle key of the left subtree will be the key of the 
     left child of the root, and the 
     The middle key of the right subtree will be the key of the right child of the root.
     An so on.  If a tree has an even number of elements, the "middle" element is (number-of-elements)/2.
    So, if a tree has four keys, the "middle" one is key #2 in <b>Ordered_Keys()</b>.  Again, I'll go over examples below.
<p>
<LI> There are helper methods in the protected part of the class.  You'll see them in use below.
</UL>

In this explanation, I do not implement <b>Height()</b> <b>Depth()</b>, <b>Ordered_Keys()</b>, 
the copy constructor or the assignment overload.  Those tasks are for you in your lab.

<hr>
<h3>The testing program: Overview and simple commands</h3>
<p>
There is a testing program in
<b><a href=bstree_test.cpp>bstree_test.cpp</a></b>.  It's a standard command line tool
for managing a tree of <b>Person</b>s:

<p><center><table border=3 cellpadding=3><td><pre>
class Person {
  public: 
    string name;
    string phone;
    string ssn; 
    void Print() const;
};
</pre></td></table></center><p>

You run it with a prompt on the command line ("-" for no prompt), and it accepts
lines of commands on standard input.  You can see the commands when you enter a question mark:

<pre>
UNIX> <font color=darkred><b>echo '?' | bin/bstree_tester </b></font>
usage: bstree_tester prompt(- for empty) -- commands on stdin.

commands:
  INSERT name phone ssn  - Insert the person into the tree.
  FIND name              - Find the person and print them out.
  DELETE person          - Delete the person.
  PRINT                  - Print the keys using the Print() method.
  EMPTY                  - Print whether the tree is empty.
  SIZE                   - Print the tree's size.
  HEIGHT                 - Print the tree's height.
  DEPTH name             - Print the depth of the node whose key is name (-1 if not there).
  KEYS                   - Print the keys using the Ordered_Keys() method.
  VALS                   - Print the vals using the Ordered_Vals() method.
  PRINT_COPY             - Call the copy constructor and call its Print() method.
  REBALANCE              - Turn the tree into a balanced tree by calling the assignment overload.
  CLEAR                  - Clear the tree back to an empty tree.
  DESTROY                - Call the destructor and remake an empty tree.
  QUIT                   - Quit.
  ?                      - Print commands.
UNIX> <font color=darkred><b></b></font>
</pre>

Here I'll show some INSERT, FIND, DELETE, KEYS and VALS commands:

<pre>
UNIX> <font color=darkred><b>bin/bstree_tester 'BST>'</b></font>
BST> <font color=darkred><b>INSERT Jim-Plank 865-123-4567 111-11-1111          <font color=blue> # I'll insert three people</b></font></font>
BST> <font color=darkred><b>INSERT Harvey-Plank 026-631-5520   826-96-9094</b></font>
BST> <font color=darkred><b>INSERT Abba 462-055-3150   827-30-6292</b></font>
BST> <font color=darkred><b>FIND Abba                                          <font color=blue> # Find returns the Person, which we print.</b></font></font>
Abba                           462-055-3150 827-30-6292
BST> <font color=darkred><b>KEYS                                               <font color=blue> # KEYS returns a vector of sorted keys, which we print</b></font></font>
Abba
Harvey-Plank
Jim-Plank
BST> <font color=darkred><b>VALS                                               <font color=blue> # VALS returns the vals pointers, in the order of the keys.</b></font></font>
Abba                           462-055-3150 827-30-6292 <b><font color=blue> # bstree_tester.cpp prints these vals.</font></b>
Harvey-Plank                   026-631-5520 826-96-9094
Jim-Plank                      865-123-4567 111-11-1111
BST> <font color=darkred><b>FIND Fred                                          <font color=blue> # FIND returns NULL when you can't find something.</b></font></font>
Not found.                                              <b><font color=blue> # bstree_tester.cpp prints "Not found." when this happpens.</font></b>
BST> <font color=darkred><b>DELETE Abba                                        <font color=blue> # Here, we delete "Abba".</b></font></font>
BST> <font color=darkred><b>VALS</b></font>
Harvey-Plank                   026-631-5520 826-96-9094
Jim-Plank                      865-123-4567 111-11-1111
BST> <font color=darkred><b>FIND Abba</b></font>
Not found.
BST> <font color=darkred><b>QUIT</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>

Take a look at how the code that inserts people into the tree.  
Each line of input is put into the vector <b>sv</b> of the individual words on a line.  This shows
how we cast to a <b>(void *)</b> when we call <b>Insert()</b>:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* With the INSERT command, we create a Person, and then insert it into the tree with
   the name as its key, and a pointer to the person (cast as a (void *)</font>) as its val. */</font>

} else if (sv[0] == "INSERT") {
  if (sv.size() != 4) {
    cout &lt;&lt; "usage: INSERT name phone ssn" &lt;&lt; endl;
  } else {
    p = new Person;
    p-&gt;name = sv[1];
    p-&gt;phone = sv[2];
    p-&gt;ssn = sv[3];
    if (!t1-&gt;Insert(p-&gt;name, (void *)</font> p)) {              <font color=blue>/* Here's where we cast to a (void *) */</font>
      cout &lt;&lt; "Insert " &lt;&lt; p-&gt;name &lt;&lt; " failed." &lt;&lt; endl;
      delete p;
    }
  }
</pre></td></table></center><p>

And below, I show how <b>Find()</b> returns a <b>(void *)</b>, but it is cast to a <b>(Person *)</b> for printing.

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* The Find() method returns a (void *)</font>, so I must typecast it to a (Person *) */</font>

} else if (sv[0] == "FIND") {
  if (sv.size() != 2) {
    cout &lt;&lt; "usage: FIND key" &lt;&lt; endl;
  } else {
    p = (Person *)</font></font> t1-&gt;Find(sv[1]);   <font color=blue>/* Here is where we typecast the (void *) to a (Person *). */</font>
    if (p == NULL) {
      cout &lt;&lt; "Not found.\n";
    } else {
      p-&gt;Print();
    }
  }
</pre></td></table></center><p>

And finally, take a look at how 
<b><a href=src/bstree_tester.cpp>src/bstree_tester.cpp</a></b>
gets all of the <b>vals</b> in the tree by calling <b>Ordered_Vals()</b>.  This is an array
of <b>(void *)'s</b>, so each of these must be typecast to a <b>(Person *)</b> to print:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* The VALS command calls Ordered_Vals() to get a vector of (void *)</font>'s.
   We typecast each to a (Person *)</font> and then print the person. */</font>

} else if (sv[0] == "VALS") {
  vals = t1-&gt;Ordered_Vals();
  for (i = 0; i &lt; vals.size(); i++) {
    p = (Person *)</font> vals[i];
    p-&gt;Print();
  }
</pre></td></table></center><p>

<hr>
<h3>The Print() method and the PRINT command</h3>

The <b>Print()</b> method prints the tree with a special format.  The tree is printed in a 
reverse inorder traversal, and each node of the tree is indented with <i>2d</i> spaces, if
the node's depth is <i>d</i>.  Here's an example:

<pre>
UNIX> <font color=darkred><b>bin/bstree_tester '--------->'</b></font>
---------> <font color=darkred><b>INSERT Binky     944-867-2246   165-79-8849</b></font>
---------> <font color=darkred><b>INSERT Fred      026-631-5520   826-96-9094</b></font>
---------> <font color=darkred><b>INSERT Luther    462-055-3150   827-30-6292</b></font>
---------> <font color=darkred><b>INSERT Waluigi   193-149-4333   106-62-2934</b></font>
---------> <font color=darkred><b>INSERT Daisy     257-554-8530   481-12-6340</b></font>
---------> <font color=darkred><b>INSERT Luigi     018-992-9715   512-23-5507</b></font>
---------> <font color=darkred><b>INSERT Ernie     808-602-6582   702-11-9340</b></font>
---------> <font color=darkred><b>INSERT Calista   457-440-4397   076-91-9105</b></font>
---------> <font color=darkred><b>PRINT</b></font>                                        <font color=blue> # This is the same tree as above</font>
      Waluigi
    Luther
      Luigi
  Fred
      Ernie
    Daisy
      Calista
Binky
---------> <font color=darkred><b>INSERT Alvin 345-654-3434   242-55-4444</b></font>
---------> <font color=darkred><b>PRINT</b></font>                                        <font color=blue> # Alvin will be inserted as Binky's left child.</font>
      Waluigi
    Luther
      Luigi
  Fred
      Ernie
    Daisy
      Calista
Binky
  Alvin
---------> <font color=darkred><b>DELETE Luigi</b></font>                 <font color=blue> # Luigi has no children, so deleting him is easy</font>
---------> <font color=darkred><b>PRINT</b></font>
      Waluigi
    Luther
  Fred
      Ernie
    Daisy
      Calista
Binky
  Alvin
---------> <font color=darkred><b>DELETE Luther</b></font>                <font color=blue> #  Luther has one child, so we replace him with his child (Waluigi)</font>
---------> <font color=darkred><b>PRINT</b></font>
    Waluigi
  Fred
      Ernie
    Daisy
      Calista
Binky
  Alvin
---------> <font color=darkred><b>DELETE Fred</b></font>                  <font color=blue> # Fred has two children, so we find the node with the</font>
---------> <font color=darkred><b>PRINT</b></font>                        <font color=blue> # greatest key in his left subtree, which is Ernie, </font>
    Waluigi                             <font color=blue> # replace Fred's key and val with Ernie's key and val,</font>
  Ernie                                 <font color=blue> # and delete Ernie.</font>
    Daisy
      Calista
Binky
  Alvin
---------> <font color=darkred><b>DEPTH Binky</b></font>                  <font color=blue> # Binky is the root, which has a depth of 0</font>
0
---------> <font color=darkred><b>DEPTH Daisy</b></font>                  <font color=blue> # Daisy is two edges from the root.</font>
2
---------> <font color=darkred><b>DEPTH Calista</b></font>                <font color=blue> # And Caliste is three.</font>
3
---------> <font color=darkred><b>HEIGHT      </b></font>                 <font color=blue> # Calista has the greatest depth in the tree, so the</font>
4                                       <font color=blue> # height of the tree is Calista's depth plus one.</font>
---------> <font color=darkred><b>QUIT</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>



<hr>
<h3>The implementation in src/bstree.cpp</h3>

Ok, let's look at the interesting parts of the code that is in 
<b><a href=src/bstree.cpp>src/bstree.cpp</a></b>.  First, here's the definition of a node of the tree:

<p><center><table border=3 cellpadding=3><td><pre>
class BSTNode {
  public:
    BSTNode *left;
    BSTNode *right;
    BSTNode *parent;
    string key;
    void *val;
};
</pre></td></table></center><p>

Besides storing a key and a val, each <b>BSTNode</b> contains a pointer to its left
child, right child and parent.  As with the Dlist, we are going to have a sentinel
node that simplifies the code.  The only part of the sentinel that we're going to 
use is its <b>right</b> pointer.  That is going to point to the root of the tree.
Rather than point to <b>NULL</b>, pointers that should point to nothing will point
to the sentinel.  Thus, when we create the following tree:

<pre>
UNIX> <font color=darkred><b>bstree_test -</b></font>
<font color=darkred><b>INSERT Fred         026-631-5520   826-96-9094</b></font>
<font color=darkred><b>INSERT Binky        944-867-2246   165-79-8849</b></font>
<font color=darkred><b>INSERT Luigi        462-055-3150   827-30-6292</b></font>
<font color=darkred><b>QUIT</b></font>
UNIX> 
</pre>

It is going to have the following representation:

<p><center><table border=3><td><img src=jpg/Big-BST.jpg width=800></td></table></center><p>

The constructor, <b>size()</b> and <b>Empty()</b> are straightforward as usual.  The empty
tree has <b>sentinel->right</b> point to <b>sentinel</b>:

<p><center><table border=3 cellpadding=3><td valign=top><pre>
BSTree::BSTree()
{
  sentinel = new BSTNode;
  sentinel-&gt;parent = NULL;
  sentinel-&gt;left = NULL;
  sentinel-&gt;right = sentinel;
  sentinel-&gt;key = "---SENTINEL---";  <font color=blue>// This helps with debugging.</font>
  sentinel-&gt;val = NULL;
  size = 0;
}
</pre></td><td valign=top><pre>
bool BSTree::Size() const
{
  return size;
}
</pre></td><td valign=top><pre>
bool BSTree::Empty() const
{
  return (size == 0);
}
</pre></td></table></center><p>

The implementation of <b>Find()</b> is a simple <b>while</b> loop that either finds
the key or returns <b>NULL</b> when the sentinel has been reached:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* This is a standard search on a binary search tree. */</font>

void *BSTree::Find(const string &key) const
{
  BSTNode *n;

  n = sentinel-&gt;right;
  while (1) {
    if (n == sentinel) return NULL;
    if (key == n-&gt;key) return n-&gt;val;
    n = (key &lt; n-&gt;key) ? n-&gt;left : n-&gt;right;
  }
}
</pre></td></table></center><p>

<b>Insert()</b> starts similarly to <b>Find()</b>.  If it actually finds the key,
then it returns false.  Otherwise, the important thing is finding the parent of the
newly created node.  Once the parent is found, the new node is created, its
<b>left</b> and <b>right</b> pointers are set to be the sentinel, and its <b>parent</b>
pointer is set to be its parent.  At this point, all of its pointers are correct --
the only thing that needs to be fixed is the parent -- the new node is either 
the parent's left or right child.  Once that is figured out, the pointer is set, 
and we return true:

<p><center><table border=3 cellpadding=3><td><pre>
bool BSTree::Insert(const string &key, void *val)
{
  BSTNode *parent;
  BSTNode *n;

  parent = sentinel;
  n = sentinel-&gt;right;

  <font color=blue>/* Find where the key should go.  If you find the key, return false. */</font>

  while (n != sentinel) {
    if (n-&gt;key == key) return false;
    parent = n;
    n = (key &lt; n-&gt;key) ? n-&gt;left : n-&gt;right;
  }

  <font color=blue>/* At this point, parent is the node that will be the parent of the new node.
     Create the new node, and hook it in. */</font>

  n = new BSTNode;
  n-&gt;key = key;
  n-&gt;val = val;
  n-&gt;parent = parent;
  n-&gt;left = sentinel;
  n-&gt;right = sentinel;

  <font color=blue>/* Use the correct pointer in the parent to point to the new node. */</font>

  if (parent == sentinel) {
    sentinel-&gt;right = n;
  } else if (key &lt; parent-&gt;key) {
    parent-&gt;left = n;
  } else {
    parent-&gt;right = n;
  }

  <font color=blue>/* Increment the size and return success. */</font>

  size++;
  return true;
}
</pre></td></table></center><p>

The tough code is <b>Delete()</b>.  The first thing that we have to do is find
the node.  Once we do, we consider the three cases that are described above.  If
the node has no left child, then we replace the node with its right child.
The way we "replace" the node is we set the parent's link to that node to equal
the right child.  Otherwise, if the node has no right child, then we replace
it with its left child.
<p>
Those are the easy cases.  The hard case is when the node has two children.  In that
case, we find the maximum node whose key is less than the node's key (There are no
duplicates, which simplifies matters).  This node is in the 
variable <b>mlc</b>.  We recursively
delete <b>mlc</b>, and then replace <b>n</b>'s key and val with <b>mlc</b>'s key and val:

<p><center><table border=3 cellpadding=3><td><pre>
bool BSTree::Delete(const string &key)
{
  BSTNode *n, *parent, *mlc;
  string tmpkey;
  void *tmpval;

  <font color=blue>/* Try to find the key -- if you can't, return false. */</font>

  n = sentinel-&gt;right;
  while (n != sentinel && key != n-&gt;key) {
    n = (key &lt; n-&gt;key) ? n-&gt;left : n-&gt;right;
  }
  if (n == sentinel) return false;

  <font color=blue>/* We go through three cases for deletion. */</font>

  parent = n-&gt;parent;

  <font color=blue>/* Case 1 - I have no left child.  Replace me with my right child.
     Note that this handles the case of having no children, too. */</font>

  if (n-&gt;left == sentinel) {
    if (n == parent-&gt;left) {
      parent-&gt;left = n-&gt;right;
    } else {
      parent-&gt;right = n-&gt;right;
    }
    if (n-&gt;right != sentinel) n-&gt;right-&gt;parent = parent;
    delete n;
    size--;

  <font color=blue>/* Case 2 - I have no right child.  Replace me with my left child. */</font>

  } else if (n-&gt;right == sentinel) {
    if (n == parent-&gt;left) {
      parent-&gt;left = n-&gt;left;
    } else {
      parent-&gt;right = n-&gt;left;
    }
    n-&gt;left-&gt;parent = parent;
    delete n;
    size--;

  <font color=blue>/* If I have two children, then find the node "before" me in the tree.
     That node will have no right child, so I can recursively delete it.
     When I'm done, I'll replace the key and val of n with the key and
     val of the deleted node.  You'll note that the recursive call 
     updates the size, so you don't have to do it here. */</font>

  } else {
    for (mlc = n-&gt;left; mlc-&gt;right != sentinel; mlc = mlc-&gt;right) ;
    tmpkey = mlc-&gt;key;
    tmpval = mlc-&gt;val;
    Delete(tmpkey);
    n-&gt;key = tmpkey;
    n-&gt;val = tmpval;
  }

  return true;
}
</pre></td></table></center><p>

We need to be really careful making that recursive call.  If we set <b>n->key</b> equal to <b>tmpkey</b> before making the recursive call, we'd delete the wrong node.  Also, since the recursive
call deletes <b>mlc</b>, we can't use it following the recursive call -- this is why we stored
<b>mlc->key</b> and <b>mlc->val</b> in <b>tmpkey</b> and <b>tmpval</b>.  Finally, since the
recursive call decreases the size, we don't do it here.

<p>
The last calls are the traversals.  We do these recursively with protected methods (we don't
want to let others make these calls -- they are just for us).  Start with <b>Print()</b> --
it calls <b>recursive_inorder_print()</b> on the root of the tree (in <b>sentinel->right</b>).
<b>Recursive_inorder_print()</b> does an in-order traversal in reverse order -- it calls
itself recursively on its <i>right</i> child, then it prints the node, and finally 
it calls recursively on its left child.  It always stops when it reaches the sentinel.

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* Print() simply calls recursive_inorder_print() on the root node of the tree. */</font>

void BSTree::Print() const
{
  recursive_inorder_print(0, sentinel-&gt;right);
}
                                
<font color=blue>/* This does an inorder traversal in reverse order.  The "Action" is printing "level" spaces,
   and then the key.  You increment the level by two when you make recursive calls. */</font>

void BSTree::recursive_inorder_print(int level, const BSTNode *n) const
{
  if (n == sentinel) return;
  recursive_inorder_print(level+2, n-&gt;right);
  printf("%*s%s\n", level, "", n-&gt;key.c_str());
  recursive_inorder_print(level+2, n-&gt;left);
}
</pre></td></table></center><p>

The other two recursive traversals are <b>Ordered_Vals</b> and <b>Clear()</b>.
The first performs an in-order traversal, pushing vals onto a vector,
while the second preforms a post-order traversal, deleting nodes of the tree.  
The post-order traversal is necessary, because we can't use <b>n->left</b> or <b>n->right</b>
after we've deleted <b>n</b>.  Granted, we could store them in temporary pointers,
delete <b>n</b> and then recursively delete the temporary pointers, but the post-order
traversal is easier.

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* This simply calls make_val_vector() on the root.
   That creates the vector rv, so return it. */</font>

vector &lt;void *&gt; BSTree::Ordered_Vals() const
{
  vector &lt;void *&gt; rv;
  make_val_vector(sentinel-&gt;right, rv);
  return rv;
}

<font color=blue>/* This does an inorder traversal, which of course visits the nodes
   in sorted order of the keys.  The "action" is pushing the val onto the vector.
   That means that the vals get pushed in the correct order. */</font>
                                       
void BSTree::make_val_vector(const BSTNode *n, vector&lt;void *&gt; &v) const
{
  if (n == sentinel) return;
  make_val_vector(n-&gt;left, v);
  v.push_back(n-&gt;val);
  make_val_vector(n-&gt;right, v);
}

<font color=blue>/* Clear simply calls recursive_destroy on the root of the tree.
   That deletes all of the nodes but the sentinel.  It then sets
   the root of the tree to the sentinel and the size to 0. */</font>

void BSTree::Clear()
{
  recursive_destroy(sentinel-&gt;right);
  sentinel-&gt;right = sentinel;
  size = 0;
}
                                      
<font color=blue>/* Recursive destroy deletes all of the nodes of a tree.
   It does this with a postorder traversal -- deleting the
   children before deleting the node. */</font>

void BSTree::recursive_destroy(BSTNode *n)
{
  if (n == sentinel) return;
  recursive_destroy(n-&gt;left);
  recursive_destroy(n-&gt;right);
  delete n;
}

<font color=blue>/* The destructor calls Clear(), which deletes all of the tree but
   the sentinel node.  Therefore, it must also delete the sentinel node. */</font>

BSTree::~BSTree()
{
  Clear();
  delete sentinel;
}
</pre></td></table></center><p>

A final comment on the destructor.  Should it also delete the <b>val</b>'s?  
The answer is no -- it's good form only to delete what you create with <b>new</b>.
What if the user of this data structure didn't create the <b>val</b>'s with 
<b>new</b>, or what if the user is holding them in a second data structure?  Then
it would be really bad form for the destructor to delete it!

<hr>
<h3>The Assignment Overload and Copy Constructor</h3>

The assignment overload and copy constructor are necessary.
The reason is that without them, you'd simply copy the <b>size</b> and
<b>sentinel</b> pointer, and now you'd have two trees pointing to the same
<b>sentinel</b>.  When one of them calls its destructor, then the second one
will be pointing to deleted memory - a disaster!
<p>
With this data structure, we are making the assignment overload and copy constructor
special.  Not only do they make a copy of the tree, but they make the new copy
<i>balanced</i>.  The reason is that it will improve the performance of subsequent
<b>Insert()</b>, 
<b>Find()</b> and <b>Delete()</b> operations.  Let's take an example -- in 
<b><a href=src/bstree_tester.cpp>src/bstree_tester.cpp</a></b>, the PRINT_COPY
command calls a procedure called <b>print_copy()</b> with the tree as a parameter.
This will call the copy constructor, so that <b>print_copy()</b> gets a copy of
the original tree.  This copy will be balanced (the original tree will remain 
unchanged) -- read the inline comments:

<pre>
UNIX> <font color=darkred><b>bin/bstree_tester '--------->'</b></font>   <font color=blue> # We insert 0 through 6 in order,</font>
---------> <font color=darkred><b>INSERT 0 0 0</b></font>                <font color=blue> # which means that our tree is a big line.</font>
---------> <font color=darkred><b>INSERT 1 0 0</b></font>
---------> <font color=darkred><b>INSERT 2 0 0</b></font>
---------> <font color=darkred><b>INSERT 3 0 0</b></font>
---------> <font color=darkred><b>INSERT 4 0 0</b></font>
---------> <font color=darkred><b>INSERT 5 0 0</b></font>
---------> <font color=darkred><b>INSERT 6 0 0</b></font>
---------> <font color=darkred><b>PRINT</b></font>
            6
          5
        4
      3
    2
  1
0
---------> <font color=darkred><b>PRINT_COPY</b></font>        <font color=blue> # PRINT_COPY calls the copy constructor,</font>
    6                        <font color=blue> # which creates a balanced version of the tree. </font>
  5                          <font color=blue> # Since 3 is the middle key, it becomes the root</font>
    4                        <font color=blue> # of the tree.  Its left subtree has the values</font>
3                            <font color=blue> # 0, 1 and 2.  Since 1 is the middle of these,</font>
    2                        <font color=blue> # it is the root of the subtree.  Similarly, the</font>
  1                          <font color=blue> # right subtree has the values 4, 5, and 6, so </font>
    0                        <font color=blue> # 5 is the root of the subtree.</font>
---------> <font color=darkred><b>PRINT</b></font>
            6                <font color=blue> # I'm doing this to show you that the original</font>
          5                  <font color=blue> # tree is unmodified.  Only the copy was balanced.</font>
        4
      3
    2
  1
0
---------> <font color=darkred><b>QUIT</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>

The assignment overload also balances.  In 
<b><a href=src/bstree_tester.cpp>src/bstree_tester.cpp</a></b>, the command "REBALANCE"
calls the assignment overload and sets the main tree pointer to be this new tree.
That way, it balances the tree.  I'm going to show that below.  Also, make note of the
fact that when a tree has an even number of elements, then there are two potential "middle"
elements.  The code here chooses the higher of the two elements.  I'll show that below.
Your code will have to do this:

<pre>
UNIX> <font color=darkred><b>bin/bstree_tester '--------->'</b></font>
---------> <font color=darkred><b>INSERT 0 0 0</b></font>    <font color=blue> # I make a big line again, this time with 8 elements</font>
---------> <font color=darkred><b>INSERT 1 0 0</b></font>
---------> <font color=darkred><b>INSERT 2 0 0</b></font>
---------> <font color=darkred><b>INSERT 3 0 0</b></font>
---------> <font color=darkred><b>INSERT 4 0 0</b></font>
---------> <font color=darkred><b>INSERT 5 0 0</b></font>
---------> <font color=darkred><b>INSERT 6 0 0</b></font>
---------> <font color=darkred><b>INSERT 7 0 0</b></font>
---------> <font color=darkred><b>PRINT</b></font>
              7
            6
          5
        4
      3
    2
  1
0
---------> <font color=darkred><b>REBALANCE</b></font>
---------> <font color=darkred><b>PRINT</b></font>
    7
  6
    5
4             <font color=blue> # Since there are 8 elements in the tree, there are two potential middles.  We choose the larger: 4</font>
    3
  2           <font color=blue> # This subtree has four elements, so there are two potential middles.  We choose the larger: 2</font>
    1         <font color=blue> # This subtree has two elements, so there are two potential middles.  We choose the larger: 1</font>
      0
---------> <font color=darkred><b>QUIT</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>

<hr>
<h3>Your Lab</h3>

Your lab is simple -- implement the following methods:

<UL>
<LI> <b>Depth()</b>
<LI> <b>Height()</b>
<LI> <b>Ordered_Keys()</b>
<LI> The assignment overload.
<LI> The copy contstructor.
</UL>

Some notes here:  
<UL>
<LI> <b>Height()</b> should use the protected method 
<b>recursive_find_height()</b>, which you'll write.
<LI> <b>Ordered_Keys()</b> should use the protected method 
<b>make_key_vector()</b>, which you'll write.
<LI> The assignment overload should call <b>Ordered_Keys()</b> to get a vector of keys in
sorted order, and 
<b>Ordered_Vals()</b> to get a vector of vals that correspond to the keys.  It should then
call <b>make_balanced_tree()</b> to create a subtree of the given region of the keys/vals.
<b>make_balanced_tree()</b> should be recursive, and should work by creating the tree in
a postorder manner.  
<p>
I'll give an example.  Suppose the keys are "0" through "6" as above.  Then here are the 
calls to <b>make_balanced_tree()</b>:

<UL>
<LI> The first call will be <b>make_balanced_tree(keys, vals, 0, 7).</b>
<LI> That will call <b>make_balanced_tree(keys, vals, 0, 3)</b> and <b>make_balanced_tree(keys, vals, 4, 3)</b>.
<LI> <b>make_balanced_tree(keys, vals, 0, 3)</b> will call <b>make_balanced_tree(keys, vals, 0, 0)</b> and <b>make_balanced_tree(keys, vals, 2, 0)</b>.
<LI> <b>make_balanced_tree(keys, vals, 4, 3)</b> will call <b>make_balanced_tree(keys, vals, 4, 0)</b> and <b>make_balanced_tree(keys, vals, 6, 0)</b>.
<LI> The rest of the <b>make_balanced_tree()</b> calls won't make recursive calls, because they 
     won't have any subtrees.
</UL>
<p>
<LI> The copy constructor should call the assignment overload (see the copy constructor for
     stacks in the  <a href=http://web.eecs.utk.edu/~jplank/plank/classes/cs140/Notes/Linked/index.html>Linkd Data Structures</a> lecture.
</UL>

<hr>
<h3>Running times</h3>

I know that this has been a long lecture -- this is the last section!
<p>
For general trees, you should know the following things:

<UL>
<LI> A tree with <i>n</i> nodes has <i>n-1</i> edges.
<LI> Therefore the number of edges is <i>O(n)</i>.
<LI> All tree traversals are <i>O(n)</i>.
</UL>

For binary search trees, you should know the following things:

<UL>
<LI> The running times of <b>Find()</b>, <b>Insert()</b>, <b>Delete()</b> and <b>Depth()</b> 
     are all <i>O(h)</i>, where <i>h</i> is the height of the tree.
<LI> Binary search trees do not have to be balanced (the see example with the copy constructor above).  That means that a binary search tree can easily have a height <i>h</i> which is <i>O(n)</i>.
<LI> Therefore the worst case running times of <b>Find()</b>, <b>Insert()</b>, <b>Delete()</b> 
     and <b>Depth()</b> are <i>O(n)</i>.
<LI> The worst case of creating a binary search tree with <i>n</i> elements is 
     <i>O(n<sup>2</sup>)</i>.  One way to do that is to insert all of the keys in sorted order.
<LI> When a tree is balanced, its height is <i>O(log(n))</i>.
<LI> So on a balanced binary search tree, 
the running times of <b>Find()</b>, <b>Insert()</b>, <b>Delete()</b> 
     and <b>Depth()</b> are <i>O(log(n))</i>.
<LI> All of the traversals are still <i>O(n)</i>, so <b>Height()</b>, <b>Print()</b>, 
<b>Ordered_Keys()</b>, <b>Ordered_Vals()</b>, <b>Clear()</b>, 
the destructor, the copy constructor and the
assignment overload are all <i>O(n)</i>.
</UL>


