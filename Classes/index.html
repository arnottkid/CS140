<title>CS140 Lecture Notes</title>
<h2>CS140 Lecture Notes - Classes, Header/Source/Object/Executable Files</h2>
<UL>
<LI> James S. Plank, with help from Brad Vander Zanden
<LI> Original Lecture: August 29, 2009.
     Complete Overhaul: September, 2019.
<LI> Directory: <b>/home/plank/cs140/Notes/Classes</b>
</UL>

<h2> Overview, Compilation and Structure</h2>

This is a big lecture.  My goal with this is to show you a typical well-structured
Unix directory which includes a C++ class, and a suite of programs that make use of it.
The class that we are going to implement is a game player for Tic-Tac-Toe.  Before
going into the code, let's talk about our directory structure.  We have four directories:

<UL>
<LI> <b>include</b>: This contains header files.  They all have the suffix <b>.hpp</b>.
<LI> <b>src</b>: This contains source code.  All of the files have the suffix <b>.cpp</b>.
<LI> <b>obj</b>: This contains <i>object</i> files.  These are compiled source code files, but
     not programs.  When you break up a program over multiple source code files, you can compile
     each to an object file, and then <i>link</i> the object files to create an executable.
     Each object file does not have to have a <b>main()</b>, and it doesn't have to have all
     procedures/methods/classes defined.  However, when you link them together, everything has
     to be defined in one of the object files.
<LI> <b>bin</b>: This contains <i>executable</i> programs.  Each of these is created by <i>linking</i>
     multiple object (and/or source) files, which contain all of the definitions/implementations.
</UL>

In this lecture, we define a class called <tt>Tic_Tac_Toe</tt> in the header file 
<b>include/tic_tac_toe.hpp</b>.  This defines the methods and variables in the class.  However, it
does not implement the methods.  That is done in <b>src/tic_tac_toe.cpp</b>.  When we compile 
<b>src/tic_tac_toe.cpp</b>, it will be to the object file <b>obj/tic_tac_toe.o</b>.  
<p>
Since <b>src/tic_tac_toe.cpp</b> does not have a <b>main()</b>, it is not a complete program.
I have three different programs that have <b>main()'s</b>, and make use of the <tt>Tic_Tac_Toe</tt>
class.  These are:

<UL>
<LI> <b>src/ttt_tester.cpp</b>: This is a program that I've written so that I can test 
     my implementation.  It is a little cumbersome to use, but it was helpful for me when I
     developed the code for <b>src/tic_tac_toe.cpp</b>.
<p>
<LI> <b>src/ttt_player.cpp</b>: This is a program that uses the class to play the game interactively
    in a more natural way than  <b>src/ttt_tester.cpp</b>. 
<p>
<LI> <b>src/ttt_random.cpp</b>: This is a program where I choose random places for X and O, with the
     exception of the first move for X, which I put in the middle square.  The idea here is to see if
     that gives X an advantage, even when X plays randomly for the rest of the game.
</UL>

Now, each <b>.cpp</b> file will have the line:

<p><center><table border=3 cellpadding=3><td><pre>
#include "tic_tac_toe.hpp"
</pre></td></table></center><p>

That means that every <b>.cpp</b> file has the same specification of the <tt>Tic_Tac_Toe</tt> class.
To compile each source file into an object file, we will do the following, using <b>src/tic_tac_toe.cpp</b>
as an example:


<pre>
UNIX> <font color=darkred><b>g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/tic_tac_toe.o src/tic_tac_toe.cpp</b></font>
</pre>
UNIX> 

Let's go over each part of this:

<UL>
<LI> <tt>-std=c++98</tt> means we are using the 1998 standard of C++.
<LI> <tt>-Wall and -Wextra</tt> have the compiler spit out more warnings than usual.  This helps us find bugs.
<LI> <tt>-Iinclude</tt> says to look in the directory <b>include</b> to find header files that are inside double-quotes.  That allows us to say <tt>#include "tic_tac_toe.hpp"</tt>, and the compiler
will find the file <b>include/tic_tac_toe.hpp</b>.
<LI> <tt>-c</tt> says to just create an object file, and not to try to create an executable.
<LI> <tt>-o obj/tic_tac_toe.o</tt> says to put the object file into the <b>obj</b> directory with the given filename.  If we didn't specify <tt>-o</tt>, then the object file would go into the 
current directory.
<LI> <tt>src/tic_tac_toe.cpp</tt> specifies the file that we are compiling.
</UL>

When we want to create an executable, we <i>link</i> together the object files, where one of them 
has a <b>main()</b>, and the others contain implementations of everything that is used.  For example,
when we want to make an executable from <b>src/ttt_tester.cpp</b>, we do:

<pre>
UNIX> <font color=darkred><b>g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_tester obj/ttt_tester.o obj/tic_tac_toe.o</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>

Since we don't include the <tt>-c</tt> flag, it makes the executable.  The <b>main()</b> is defined in
<b>src/ttt_tester.o</b>.  It uses the <tt>Tic_Tac_Toe</tt> class, so we include <b>src/tic_tac_toe.o</b>,
which implements all of the methods of the class.  If we don't include <b>src/tic_tac_toe.o</b>, 
then we'll get a compiler error, saying that methods have not been implemented:

<pre>
UNIX> <font color=darkred><b>g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_tester obj/ttt_tester.o </b></font>
Undefined symbols for architecture x86_64:
  "Tic_Tac_Toe::Clear_Game()", referenced from:
      _main in ttt_tester.o
  "Tic_Tac_Toe::Make_Move(char, unsigned long, unsigned long)", referenced from:
      _main in ttt_tester.o
  "Tic_Tac_Toe::Tic_Tac_Toe()", referenced from:
      _main in ttt_tester.o
  "Tic_Tac_Toe::Game_State() const", referenced from:
      _main in ttt_tester.o
  "Tic_Tac_Toe::Board_String() const", referenced from:
      _main in ttt_tester.o
  "Tic_Tac_Toe::Print() const", referenced from:
      _main in ttt_tester.o
  "Tic_Tac_Toe::Stats(std::__1::vector<int, std::__1::allocator<int> >&) const", referenced from:
      _main in ttt_tester.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
UNIX> <font color=darkred><b></b></font>
</pre>

Now, the file <b><a href=makefile>makefile</a></b> automates the compilation.  If you type
"make clean", then it will remove all of the object files and executables.  Then, if you type
"make" or "make all", it will make all of the object files and executables.

<pre>
UNIX> <font color=darkred><b>make clean</b></font>
rm -f obj/* bin/*
UNIX> <font color=darkred><b>make</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/ttt_tester.o src/ttt_tester.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/tic_tac_toe.o src/tic_tac_toe.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_tester obj/ttt_tester.o obj/tic_tac_toe.o
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/ttt_player.o src/ttt_player.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_player obj/ttt_player.o obj/tic_tac_toe.o
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/ttt_random.o src/ttt_random.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_random obj/ttt_random.o obj/tic_tac_toe.o
UNIX> <font color=darkred><b></b></font>
</pre>

Let me draw a picture of what is going on.  This shows how the source files all include the
include file, how they are compiled to object files, and which object files are linked together to 
make which executables:

<p><center><table border=3><td><img src=structure.png width=600></td></table></center><p>

<hr>
<h3>The header file: include/tic_tac_toe.hpp</h3>

Let's take a look at the header file in 
<b><a href=include/tic_tac_toe.hpp>include/tic_tac_toe.hpp</a></b>.  It defines a class
with a constructor and six public methods.  The comments tell you what the methods do.  It also
defines four protected variables.  We'll talk more about them later.

<p><center><table border=3 cellpadding=3><td><pre>
#pragma once
 
#include &lt;vector&gt;
#include &lt;string&gt;

class Tic_Tac_Toe
{
  public:
    Tic_Tac_Toe();                    <font color=blue>/* Constructor */</font>
    void Clear_Game();                <font color=blue>/* Turn the current board into an empty board */</font>
    char Game_State() const;          <font color=blue>/* Return the state of the game:
                                           'B' = beginning of game
                                           'X' = X's turn
                                           'O' = O's turn
                                           'x' = Game is over and X has won.
                                           'o' = Game is over and O has won.
                                           'd' = Game is over and it's a draw. */</font>

    char Make_Move(char xo, size_t row, size_t col);  <font color=blue>/* This does the move.  
                                                         xo must be 'X' or 'O'.
                                                         Returns 'E' on an error.
                                                         Otherwise it returns resulting game state. */</font>

    void Print() const;                         <font color=blue>/* Prints the board. */</font>
    std::string Board_String() const;           <font color=blue>/* Returns a 9-character string of X's, O's and -'s */</font>
    void Stats(std::vector &lt;int&gt; &xod) const;   <font color=blue>/* Sets xod to a three element vector: 
                                                   X wins, O wins, draws */</font>

  protected:
    std::vector &lt;std::string&gt; Board;    <font color=blue>/* The board */</font>
    char State;                         <font color=blue>/* Game state -- same values as Game_State() above */</font>
    std::vector &lt;int&gt; X_O_D;            <font color=blue>/* The three stats */</font>
    int Open_Squares;                   <font color=blue>/* The number of open squares on the board. */</font>
};
</pre></td></table></center><p>

First, you'll note that the methods are <b>public</b>.  That means that anyone who creates an instance of
the class can use the methods.  The methods give you enough power to run tic-tac-toe games, and keep track
of the winners.  Second, you should see the use of the <b>const</b> keyword.  Here it is put at the end
of any method that doesn't change the class.  For example, <b>Print()</b> prints the game board, but doesn't
change anything.  That allows the compiler to double-check that indeed your implementation doesn't
change anything, and it helps you find bugs.  Third, there's no "using namespace std" in the header
file, so when I need to use things that are part of the "std" namespace, I need to put "std::" in front
of them.  You see that I've done this with <b>vector</b> and <b>string</b>.  This is good practice, because
some programmers don't want to have "using namespace std" in their code, and this way, you don't force them
to do so.  You can always put it in your own source (.cpp) files.  Fourth, the variables are all
<b>protected</b>.  That means that they can only be accessed by the methods of the class, and not
by any other code.  Thus, the only way that you can use the class is through its methods.

<p>
Last, I have no executable code in the header file.  This is something in which I believe firmly -- header
files should have no executable code.  That includes have a constructor that sets default values.  That should
be in the implementation.

<hr>
<h3>Starting to implement the class: src/tic_tac_toe_1.cpp</h3>

Having defined my class, I need to implement and test it.  You need to resist the temptation to do this all
in one shot, even with a class that's as easy as this one.  Here's what I did to implement the class.
The first thing I did was write 
<b><a href=src/tic_tac_toe_1.cpp>src/tic_tac_toe_1.cpp</a></b>.  This simply has dummy methods
for every method in the class.  I want to write some testing code next, and this allows me to 
compile and make sure that at least it's calling stuff correctly.  Put another way, it allows
me to test my header to make sure that it's correct and usable.

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* This implementation file simply has dummy methods for every method in the class.
   It allows me to write a testing program and have it compile.  Then, I'll start
   to implement the methods. */</font>

#include "tic_tac_toe.hpp"
using namespace std;

Tic_Tac_Toe::Tic_Tac_Toe() {}

void Tic_Tac_Toe::Clear_Game() {}

void Tic_Tac_Toe::Print() const {}

char Tic_Tac_Toe::Game_State() const { return '-'; }

string Tic_Tac_Toe::Board_String() const { return "-"; }

void Tic_Tac_Toe::Stats(vector &lt;int&gt; &xod) const 
{ 
  xod.resize(3, 0); 
}

char Tic_Tac_Toe::Make_Move(char xo, size_t row, size_t col) 
{ 
  (void) xo;        <font color=blue>// These statements shut the compiler up about not using the parameters.</font>
  (void) row;
  (void) col;
  return 'E'; 
}
</pre></td></table></center><p>

You can see that I've put "using namespace std" here -- that's because I'm happy to 
use the "std" namespace, and make my code more readable.
<p>
I've added a "make develop" to my makefile, which is where I specify how to compile
the code that I'm using while I'm writing the program.   I won't use it yet -- here, I'll
simply type "make obj/tic_tac_toe_1.o", because I've configure that to just compile
<b>src/tic_tac_toe_1.cpp</b>:

<pre>
UNIX> <font color=darkred><b>make obj/tic_tac_toe_1.o</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/tic_tac_toe_1.o src/tic_tac_toe_1.cpp
UNIX> <font color=darkred><b></b></font>
</pre>

<hr>
<h3>The testing program: src/ttt_tester.cpp</h3>

Next, I wrote my testing program, which is in 
<b><a href=src/ttt_tester.cpp>src/ttt_tester.cpp</a></b>. I write a lot of testing
programs like this -- pretty much for every class that I create.  The structure is simple
-- it reads lines of text and converts them to vectors of words.  It processes one line
at a time, using the first word as a command.  You can see the commands below in the
procedure <b>print_commands()</b>.  What you see is that there is a command to test each
method of the class.

<p><center><table border=3 cellpadding=3><td><pre>
#include "tic_tac_toe.hpp"
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
using namespace std;

<font color=blue>/* It's good to put this in a procedure at the beginning of your file -- that
   way you know where it is for reference, while you're writing the program. */</font>

void print_commands()
{
  cout &lt;&lt; "usage: ttt_tester -- commands on stdin." &lt;&lt; endl;
  cout &lt;&lt; endl;
  cout &lt;&lt; "commands:" &lt;&lt; endl;
  cout &lt;&lt; "  C            - Clear game state." &lt;&lt; endl;
  cout &lt;&lt; "  GS           - Print the game state char." &lt;&lt; endl;
  cout &lt;&lt; "  P            - Print the board." &lt;&lt; endl;
  cout &lt;&lt; "  BS           - Print the Board String." &lt;&lt; endl;
  cout &lt;&lt; "  S            - Print stats." &lt;&lt; endl;
  cout &lt;&lt; "  M X/O R C    - Move X or O to space at row R, col C." &lt;&lt; endl;
  cout &lt;&lt; "  Q            - Quit." &lt;&lt; endl;
  cout &lt;&lt; "  ?            - Print commands." &lt;&lt; endl;
}


int main()
{
  string s, line;         <font color=blue>// I use these to read a line of text and turn it into a </font>
  vector &lt;string&gt; sv;     <font color=blue>// vector of strings (which is in sv).</font>
  istringstream ss;

  Tic_Tac_Toe ttt;        <font color=blue>// Here's my tic-tac-toe game.</font>
  vector &lt;int&gt; stats;     <font color=blue>// This is for when I call ttt.Stats()</font>

  int row, col;           <font color=blue>// These are for the ttt.Make_Move(xo, row, col) call.</font>
  char xo;

  while (1) {
 
    <font color=blue>/* Print a prompt, and read in a line. */</font>

    cout &lt;&lt; "TTT&gt; ";
    cout.flush();
    if (!getline(cin, line)) return 0;

    <font color=blue>/* Use a stringstream to turn the line into a vector of words. */</font>

    sv.clear();
    ss.clear();
    ss.str(line);
    while (ss &gt;&gt; s) sv.push_back(s);

    <font color=blue>/* Ignore blank lines and lines that start with the pound sign. */</font>

    if (sv.size() == 0 || sv[0][0] == '#') {

    <font color=blue>/* Handle the simple commands: */</font>

    } else if (sv[0] == "P") {
      ttt.Print();
    } else if (sv[0] == "C") {
      ttt.Clear_Game();
    } else if (sv[0] == "GS") {
      printf("%c\n", ttt.Game_State());
    } else if (sv[0] == "BS") {
      printf("%s\n", ttt.Board_String().c_str());

    <font color=blue>/* Stats */</font>

    } else if (sv[0] == "S") {
      ttt.Stats(stats);
      printf("X Wins: %4d\n", stats[0]);
      printf("O Wins: %4d\n", stats[1]);
      printf("Draws:  %4d\n", stats[2]);

    <font color=blue>/* Make a move.  
       You'll note that I'm not using a stringstream for row/col.  This code
       is simpler, and since row and col have to be between 0 and 2, it works
       just fine.  You'll note that I'm not doing much error-checking here.
       That will be handled in Make_Move() which returns 'E' if it is called
       incorrectly.  */</font>

    } else if (sv[0] == "M") {
      if (sv.size() != 4) {
        printf("Usage M X/O row col\n");
      } else {
        xo = sv[1][0];
        row = sv[2][0] - '0';
        col = sv[3][0] - '0';
        printf("Result of move: %c\n", ttt.Make_Move(xo, row, col));
      }

    <font color=blue>/* Quit, print commands or a bad command. */</font>

    } else if (sv[0] == "Q") {
      return 0;
    } else if (sv[0] == "?") {
      print_commands();
    } else {
      printf("Unknown command %s\n", sv[0].c_str());
    }
  }
}
</pre></td></table></center><p>

The program is really simple, and it lets me write <b>tic_tac_toe.cpp</b> incrementally, by writing
a few methods at a time, and then testing.  This compiles with 
<b>src/tic_tac_toe_1.cpp</b>, and now you can "test" it.  Of course, it doesn't really do anything, but
at least you have everything compiling together are are ready to start implementing.   In my makefile,
I have this compile with <b>src/tic_tac_toe_1.cpp</b> to make the executable <b>bin/ttt_tester_1</b>:

<pre>
UNIX> <font color=darkred><b>make clean</b></font>
rm -f obj/* bin/*
UNIX> <font color=darkred><b>make bin/ttt_tester_1</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/ttt_tester.o src/ttt_tester.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/tic_tac_toe_1.o src/tic_tac_toe_1.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_tester_1 obj/ttt_tester.o obj/tic_tac_toe_1.o
UNIX> <font color=darkred><b></b></font>
</pre>

I'll run it, and it won't do much, but it lets me see that the methods are being called:

<pre>
UNIX> <font color=darkred><b>bin/ttt_tester_1</b></font>
TTT> <font color=darkred><b>?</b></font>
usage: ttt_tester -- commands on stdin.

commands:
  C            - Clear game state.
  GS           - Print the game state char.
  P            - Print the board.
  BS           - Print the Board String.
  S            - Print stats.
  M X/O R C    - Move X or O to space at row R, col C.
  Q            - Quit.
  ?            - Print commands.
TTT> <font color=darkred><b>C</b></font>                                        <font color=blue># call ttt.Clear()</font>
TTT> <font color=darkred><b>GS</b></font>                                       <font color=blue># call ttt.Game_State()</font>
-
TTT> <font color=darkred><b>P</b></font>                                        <font color=blue># call ttt.Print()</font>
TTT> <font color=darkred><b>BS</b></font>                                       <font color=blue># call ttt.Board_String()</font>
-
TTT> <font color=darkred><b>S</b></font>                                        <font color=blue># call ttt.Stats()</font>
X Wins:    0
O Wins:    0
Draws:     0
TTT> <font color=darkred><b>M - - - </b></font>                                 <font color=blue># call ttt.Make_Move()</font>
Result of move: E
TTT> <font color=darkred><b>Q</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>

<hr>
<h3>Implementing the easy methods: src/tic_tac_toe_2.cpp</h3>

In
<b><a href=src/tic_tac_toe_2.cpp>src/tic_tac_toe_2.cpp</a></b>, I implement all of the methods,
except for <b>Make_Move()</b>. These are all really straightforward, and you can read what
they do in their comments:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* In this program, I implement the easy methods, which is all of the methods besides Make_Move() */</font>

#include "tic_tac_toe.hpp"
#include &lt;iostream&gt;
using namespace std;

<font color=blue>/* The constructor calls Clear_Game() to set up the empty board.
   It also creates the X_O_D vector and sets its entries to zero. */</font>

Tic_Tac_Toe::Tic_Tac_Toe() 
{
  Clear_Game();
  X_O_D.resize(3, 0);
}

<font color=blue>/* Clear_Game() creates an empty board with all dashes.  It sets the game state
   to 'B', for "Beginning", and sets the number of open squares to 9, since 
   all of the squares are empty. */</font>

void Tic_Tac_Toe::Clear_Game() 
{
  State = 'B';
  Board.clear();
  Board.push_back("---");
  Board.push_back("---");
  Board.push_back("---");
  Open_Squares = 9;
}

<font color=blue>/* Print() is simple, printing out the Board, one row per line. */</font>

void Tic_Tac_Toe::Print() const 
{
  size_t i;

  for (i = 0; i &lt; Board.size(); i++) cout &lt;&lt; Board[i] &lt;&lt; endl;
}

<font color=blue>/* Game_State() is also simple, simply returning the State variable. */</font>

char Tic_Tac_Toe::Game_State() const 
{
  return State; 
}

<font color=blue>/* Board_String() concatenates the three rows of the Board together to make a single
   string without any newlines. */</font>

string Tic_Tac_Toe::Board_String() const 
{ 
  string rv;

  rv = Board[0] + Board[1] + Board[2];
  return rv;
}

<font color=blue>/* State() just copies X_O_D to its argument, which is a reference parameter. */</font>

void Tic_Tac_Toe::Stats(vector &lt;int&gt; &xod) const 
{ 
  xod = X_O_D;
}

<font color=blue>/* Make_Move() is still unwritten. */</font>

char Tic_Tac_Toe::Make_Move(char xo, size_t row, size_t col) 
{
  (void) xo;
  (void) row;
  (void) col;
  return '.'; 
}
</pre></td></table></center><p>

We can go ahead and test to see if these all work -- again, they are pretty simple, and 
since you can't make a move, they don't ever change.  The makefile will compile this
and <b>src/ttt_tester.o</b> into <b>bin/ttt_tester_2</b>:

<pre>
UNIX> <font color=darkred><b>make clean</b></font>
rm -f obj/* bin/*
UNIX> <font color=darkred><b>make bin/ttt_tester_2</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/ttt_tester.o src/ttt_tester.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/tic_tac_toe_2.o src/tic_tac_toe_2.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_tester_2 obj/ttt_tester.o obj/tic_tac_toe_2.o
UNIX> bin/ttt_tester_2
TTT> <font color=darkred><b>P</b></font>
---
---
---
TTT> <font color=darkred><b>GS</b></font>
B
TTT> <font color=darkred><b>S</b></font>
X Wins:    0
O Wins:    0
Draws:     0
TTT> <font color=darkred><b>BS</b></font>
---------
TTT> <font color=darkred><b>C</b></font>
TTT> <font color=darkred><b>P</b></font>
---
---
---
TTT> <font color=darkred><b>Q</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>

<hr>
<h3>Implementing and testing Make_Move()</h3>

<b>Make_Move()</b> is the hard procedure.  It is implemented in
<b><a href=src/tic_tac_toe.cpp>src/tic_tac_toe.cpp</a></b> -- all of the other
methods are copied over from <b>src/tic_tac_toe_2.cpp</b>.  The implementation is
explained in the comments.  The code to test whether the caller has won feels a 
little clunky, but it is at least straightforward: 

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* Make_Move() goes through the following steps:

   - Error check the arguments
   - Update the Board and Open_Squares
   - Test to see if whoever called Make_Move() has now won the game.  If so,
     update the stats and set the State to 'x' or 'o'.
   - Otherwise, test to see if the game is a Draw, and set its state to 'D'.
   - Finally, if the game isn't over, set the game state to 'X' or 'O' 
     to indicate whose turn it is. */</font>

char Tic_Tac_Toe::Make_Move(char xo, size_t row, size_t col) 
{
  bool win;                  <font color=blue>// This is used to record whether the caller has won the game.</font>
 
  <font color=blue>/* Error Check */</font>

  if (xo != 'X' && xo != 'O') return 'E';
  if (xo == 'X' && State != 'B' && State != 'X') return 'E';
  if (xo == 'O' && State != 'B' && State != 'O') return 'E';
  if (row &gt;= 3) return 'E';
  if (col &gt;= 3) return 'E';
  if (Board[row][col] != '-') return 'E';

  <font color=blue>/* Update the Board and decrement the number of open squares */</font>

  Board[row][col] = xo;
  Open_Squares--;

  <font color=blue>/* Test to see if whoever calls Make_Move has won.  The tests go in the following order:
       - Check to see if the move completed a row.
       - Check to see if the move completed a column.
       - Check to see if the move completed the \ diagonal
       - Check to see if the move completed the / diagonal */</font>

  if (Board[row][0] == Board[row][1] && Board[row][0] == Board[row][2]) {
    win = true;
  } else if (Board[0][col] == Board[1][col] && Board[0][col] == Board[2][col]) {
    win = true;
  } else if (row == col && Board[0][0] == Board[1][1] && Board[0][0] == Board[2][2]) {
    win = true;
  } else if (row+col == 2 && Board[0][2] == Board[1][1] && Board[2][0] == Board[1][1]) {
    win = true;
  } else {
    win = false;
  }

  <font color=blue>/* If the player won the game, update the stats and state accordingly. */</font>

  if (win) {
    if (xo == 'X') {
      State = 'x';
      X_O_D[0]++;
    } else if (xo == 'O') {
      State = 'o';
      X_O_D[1]++;
    }

  <font color=blue>/* Otherwise, if the game is a draw, then update the stats and state accordingly. */</font>

  } else if (Open_Squares == 0) {
    State = 'D';
    X_O_D[2]++;

  <font color=blue>/* Otherwise, set the State to whoever's turn it is. */</font>

  } else if (xo == 'X') {
    State = 'O';
  } else {
    State = 'X';
  }

  <font color=blue>/* Finally, return the state. */</font>

  return State;
}
</pre></td></table></center><p>

We can now compile <b>bin/ttt_tester</b>, and test the program:

<pre>
UNIX> <font color=darkred><b>make clean</b></font>
rm -f obj/* bin/*
UNIX> <font color=darkred><b>make bin/ttt_tester</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/ttt_tester.o src/ttt_tester.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/tic_tac_toe.o src/tic_tac_toe.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_tester obj/ttt_tester.o obj/tic_tac_toe.o
UNIX> <font color=darkred><b>bin/ttt_tester</b></font>
TTT> <font color=darkred><b>M Fred Binky Luigi</b></font>                   <font color=blue># Error checking</font>
Result of move: E
TTT> <font color=darkred><b>M X 5 3</b></font>
Result of move: E
TTT> <font color=darkred><b>M X 1 1</b></font>                              <font color=blue># Put an X in the middle square (remember, 0-indexing)</font>
Result of move: O
TTT> <font color=darkred><b>M O 0 1</b></font>                              <font color=blue># Put an O into the top middle square</font>
Result of move: X
TTT> <font color=darkred><b>P</b></font>                                    <font color=blue># Print the board</font>
-O-
-X-
---
TTT> <font color=darkred><b>M X 2 2 </b></font>                             <font color=blue># Put an X in bottom right square</font>
Result of move: O
TTT> <font color=darkred><b>M O 0 0</b></font>                              <font color=blue># Put an O in the top left square</font>
Result of move: X
TTT> <font color=darkred><b>P</b></font>                                    <font color=blue># Print the board</font>
OO-
-X-
--X
TTT> <font color=darkred><b>M X 0 2</b></font>                              <font color=blue># Put an X in top right square.  O is in trouble.</font>
Result of move: O
TTT> <font color=darkred><b>M O 0 2</b></font>                              <font color=blue># Error check putting an O into a square with an X</font>
Result of move: E
TTT> <font color=darkred><b>M O 1 2</b></font>                              <font color=blue># Put an O in the middle right square.</font>
Result of move: X
TTT> <font color=darkred><b>P</b></font>                                    <font color=blue># Print the board</font>
OOX
-XO
--X
TTT> <font color=darkred><b>M X 2 0</b></font>                              <font color=blue># X will now win the game.</font>
Result of move: x                         <font color=blue># This is confirmed by the state of 'x'</font>
TTT> <font color=darkred><b>P</b></font>
OOX
-XO
X-X
TTT> <font color=darkred><b>GS</b></font>                                   <font color=blue># Confirm the game state</font>
x
TTT> <font color=darkred><b>S</b></font>                                    <font color=blue># Show the stats.</font>
X Wins:    1
O Wins:    0
Draws:     0
TTT> <font color=darkred><b>Q</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>

You can see that the testing program is a pain to use to play the game, but it's good at testing.
It's a good idea here to test all of <b>Make_Move()</b> -- best thing is to create a file that
has commands, and then confirm that running the program on the file gives you the output
that you want.  Let me give you a simple example that plays the same game as above, but just 
prints out the board strings that result.  The program <b>sed</b> is really useful here to strip
out those "TTT>" strings, and to remove the lines that say "Result of move".
<p>
The input file is in 
<b><a href=test_game_input_1.txt>test_game_input_1.txt</a></b>

<p><center><table border=3 cellpadding=3><td><pre>
# This plays the game where X wins on the left-to-right diagonal:
M X 1 1
BS
M O 0 1
BS
M X 2 2
BS
M O 0 0
BS
M X 0 2
BS
M O 1 2
BS
M X 2 0
BS
GS
P
</pre></td></table></center><p>

When we run it, the output is pretty clunky:

<pre>
UNIX> <font color=darkred><b>bin/ttt_tester < test_game_input_1.txt </b></font>
TTT> TTT> Result of move: O
TTT> ----X----
TTT> Result of move: X
TTT> -O--X----
TTT> Result of move: O
TTT> -O--X---X
TTT> Result of move: X
TTT> OO--X---X
TTT> Result of move: O
TTT> OOX-X---X
TTT> Result of move: X
TTT> OOX-XO--X
TTT> Result of move: x
TTT> OOX-XOX-X
TTT> x
TTT> OOX
-XO
X-X
TTT> UNIX>
</pre>

However, piping it through a few <b>sed</b> commands makes it pretty clean:

<pre>
UNIX> <font color=darkred><b>bin/ttt_tester < test_game_input_1.txt | sed 's/TTT> //' | sed '/Result/d'</b></font>
----X----
-O--X----
-O--X---X
OO--X---X
OOX-X---X
OOX-XO--X
OOX-XOX-X
x
OOX
-XO
X-X

UNIX> <font color=darkred><b></b></font>
</pre>

<hr>
<h3> A more natural game player -- src/ttt_player.cpp</h3>

In 
<b><a href=src/ttt_player.cpp>src/ttt_player.cpp</a></b>, I have a program that
runs a command-line version of the game which is a lot less cumbersome than
<b>src/ttt_tester.cpp</b>.  It starts by having 'X' start the game, and then it 
alternates 'X' and 'O' starting the subsequent games.  It's a pretty simple program,
and leverages the <b>Game_State()</b> method so that it doesn't even have to keep 
track of whose turn it is.  Please read the comments for explanation.

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* This program runs a more natural command-line version of tic-tac-toe than
   src/ttt_tester.cpp.  Note how it makes use of the game state to help it
   play the game. */</font>

#include "tic_tac_toe.hpp"
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
  Tic_Tac_Toe ttt;                  <font color=blue>// The game player</font>
  vector &lt;int&gt; stats;               <font color=blue>// This is for reading the stats</font>
  size_t row, col;                  <font color=blue>// These are entered on standard input for Make_Move()</font>
  char start;                       <font color=blue>// 'X' or 'O' for who starts the game</font>
  char turn;                        <font color=blue>// 'X' or 'O' for whose turn it is</font>
  char state;                       <font color=blue>// The game state.</font>
  
  <font color=blue>/* Set it up so that 'X' plays the first game.  
     We will alternate this between games. */</font>

  start = 'X';

  while (1) {
 
    <font color=blue>/* Get the game state, and print the board. */</font>

    state = ttt.Game_State();
    cout &lt;&lt; endl;
    ttt.Print();
    cout &lt;&lt; endl;

    <font color=blue>/* If we're playing the game, then figure out whose turn it is,
       and then get the player's move from standard input. */</font>

    if (state == 'B' || state == 'X' || state == 'O') {
      turn = (state == 'B') ? start : state;
      cout &lt;&lt; turn  &lt;&lt; "'s Move: ";
      cout.flush();
      if (!(cin &gt;&gt; row &gt;&gt; col)) return 0;

      <font color=blue>/* If the move is illegal, then we print an error message.
         Then, regardless of whether the move was legal or illegal,
         we're simply going to go to the top of the while loop.
         If there was an error, we'll simply repeat this code.
         Otherwise, the game will move on. */</font>

      if (ttt.Make_Move(turn, row, col) == 'E') {
        cout &lt;&lt; endl &lt;&lt; "Bad input -- try again, please." &lt;&lt; endl;
      }
        
    <font color=blue>/* Otherwise, the game is over.  We're going to do the following things:
        - Print the winner (or whether it's a draw).
        - Print the stats.
        - Start a new game
        - Set the starting player to the other player. */</font>

    } else {
      if (state == 'D') {
        printf("Draw\n");
      } else {
        printf("%c Wins!\n", state + ('A' - 'a'));   <font color=blue>// This converts the lower-case to upper-case.</font>
      }

      ttt.Stats(stats);
      printf("Stats: X:%d O:%d D:%d\n", stats[0], stats[1], stats[2]);

      ttt.Clear_Game();
      start = (start == 'X') ? 'O' : 'X';
    }
  }
}
</pre></td></table></center><p>

Let's compile it, and play the same game as above -- you'll note, it's a lot easier
than using <b>bin/ttt_tester</b>.  (However, I'll contend that <b>bin/ttt_tester</b> is
a better program for testing).

<pre>
UNIX> <font color=darkred><b>make bin/ttt_player</b></font>
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/ttt_player.o src/ttt_player.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -c -o obj/tic_tac_toe.o src/tic_tac_toe.cpp
g++ -std=c++98 -Wall -Wextra -Iinclude -o bin/ttt_player obj/ttt_player.o obj/tic_tac_toe.o
UNIX> <font color=darkred><b>bin/ttt_player</b></font>

---
---
---



X's Move: <font color=darkred><b>1 1</b></font>

---
-X-
---

O's Move: <font color=darkred><b>0 1</b></font>

-O-
-X-
---

X's Move: <font color=darkred><b>2 2</b></font>

-O-
-X-
--X

O's Move: <font color=darkred><b>0 0</b></font>

OO-
-X-
--X

X's Move: <font color=darkred><b>0 2</b></font>

OOX
-X-
--X

O's Move: <font color=darkred><b>1 2</b></font>

OOX
-XO
--X

X's Move: <font color=darkred><b>2 0</b></font>

OOX
-XO
X-X

X Wins!
Stats: X:1 O:0 D:0

---
---
---

O's Move: <font color=darkred><b>Q</b></font>
UNIX> <font color=darkred><b></b></font>
</pre>

<hr>
<h3> Performing a scientific experiment - src/ttt_random.cpp</h3>

Our last progrom to utilize the <tt>Tic_Tac_Toe</tt> class does a little scientific
experiment.  Both the X and the O players are going to play the game randomly, with 
just one difference -- if X begins the game, he/she will choose the middle square.
The program to do is in 
<b><a href=src/ttt_random.cpp>src/ttt_random.cpp</a></b>. It takes two command-line arguments --
a number of iterations (games), and a seed for the random number generators.  It then 
plays games randomly, except for when X starts a game, in which case X will choose the
middle square.
<p>
Go ahead and read the comments for an explanation of how the code works.  The important part
of the code is how we read the board string, in the variable <i>bs</i>, and figure out the 
legal moves, which correspond to the dashes in the string.  Each of those is pushed onto the
vectors <b>legal_moves_r</b> and 
<b>legal_moves_c</b>, and we choose a random one by choosing a random index into these vectors:

<p><center><table border=3 cellpadding=3><td><pre>
<font color=blue>/* This program allows us to do a scientific experiment on tic-tac-toe.  The hypothesis is that
   if you start the game in the middle square, and then play the game randomly, you will do 
   betting than simply playing randomly. 

   The program is a nice demonstration of how our Tic_Tac_Toe class can serve multiple
   goals (playing the game interactively, and doing a scientific experiment. */</font>

#include "tic_tac_toe.hpp"
#include "MOA.hpp"
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
using namespace std;

<font color=blue>/* On the command line, we're going to read a number of iterations and a seed
   for a random number generator (this is why we included "MOA.hpp" above). */</font>

int main(int argc, char **argv)
{
  Tic_Tac_Toe ttt;                     <font color=blue>// The game player</font>
  vector &lt;int&gt; stats;                  <font color=blue>// For the final Stats() call</font>
  MOA rng;                             <font color=blue>// Random number generator</font>
  istringstream ss;                    <font color=blue>// For parsing the command line arguments</font>

  size_t iterations;                   <font color=blue>// The number of games to play</font>
  size_t seed;                         <font color=blue>// Seed for the random number generator</font>
  size_t games_played;                 <font color=blue>// Keeping track of the number of games played</font>
  char start;                          <font color=blue>// Who starts the game</font>
  char turn;                           <font color=blue>// Whose turn it is</font>
  char state;                          <font color=blue>// The game state</font>
  string bs;                           <font color=blue>// The board string, which helps do the random choosing</font>
  vector &lt;size_t&gt; legal_moves_r;       <font color=blue>// Legal moves -- the row numbers</font>
  vector &lt;size_t&gt; legal_moves_c;       <font color=blue>// Legal moves -- the column numbers</font>
  
  size_t i;

  <font color=blue>/* Parse and error check the command line */</font>

  try {
    if (argc != 3) throw((string) "usage: bin/ttt_random iterations seed");
    ss.clear(); ss.str(argv[1]); if (!(ss &gt;&gt; iterations)) throw((string) "Bad iterations");
    ss.clear(); ss.str(argv[2]); if (!(ss &gt;&gt; seed)) throw((string) "Bad seed");
  } catch (string s) {
    cout &lt;&lt; s &lt;&lt; endl;
    return 1;
  }

  <font color=blue>/* Initialize everything */</font>

  rng.Seed(seed);
  start = 'X';
  games_played = 0;
  
  <font color=blue>/* Keep going until you complete enough games.
     You only increment games_played when a game is over. */</font>

  while (games_played &lt; iterations) {
 
    <font color=blue>// printf("%s\n", ttt.Board_String().c_str());     This is useful for debugging.</font>

    <font color=blue>/* If the game isn't over, then determine whose turn it is, and then
       determine the legal moves that can be made.  Choose one of them randomly.
       When it's X's turn and it's the beginning of a game, set it up so that
       the only legal move is to use the center square. */</font>

    state = ttt.Game_State();
    if (state == 'B' || state == 'X' || state == 'O') {
      turn = (state == 'B') ? start : state;
      legal_moves_r.clear();
      legal_moves_c.clear();

      <font color=blue>/* This is how to handle when the game is starting and it's X's turn. */</font>

      if (state == 'B' && turn == 'X') {
        legal_moves_r.push_back(1);
        legal_moves_c.push_back(1);

      <font color=blue>/* Otherwise, use the dashes in the board string to determine the legal moves. */</font>

      } else {
        bs = ttt.Board_String();
        for (i = 0; i &lt; bs.size(); i++) {
          if (bs[i] == '-') {
            legal_moves_r.push_back(i/3);
            legal_moves_c.push_back(i%3);
          }
        }
      }

      <font color=blue>/* Choose a random legal move and make it. */</font>

      i = rng.Random_Integer()%legal_moves_r.size();
      ttt.Make_Move(turn, legal_moves_r[i], legal_moves_c[i]);

    <font color=blue>/* Otherwise, the game is over.  Update the games played, and set the
       starting player to the other player. */</font>

    } else {
      games_played++;
      ttt.Clear_Game();
      start = (start == 'X') ? 'O' : 'X';
    }
  }

  <font color=blue>/* At the end, print the stats. */</font>

  ttt.Stats(stats);
  printf("Stats: X:%d O:%d D:%d\n", stats[0], stats[1], stats[2]);
  return 0;
}
</pre></td></table></center><p>

To debug this, you'll note that I have <b>printf()</b> statement that I have commented out.
Those let me look at the <b>Board_String<b/> strings to make sure that everything looks good.
Let's call it on 1,000,000 games:

<pre>
UNIX> <font color=darkred><b>bin/ttt_random 1000000 40</b></font>
Stats: X:490563 O:388761 D:120676
UNIX> <font color=darkred><b>bin/ttt_random 1000000 41</b></font>
Stats: X:490699 O:388937 D:120364
UNIX> <font color=darkred><b>bin/ttt_random 1000000 42</b></font>
Stats: X:490144 O:388883 D:120973
UNIX> <font color=darkred><b>bin/ttt_random 1000000 43</b></font>
Stats: X:491100 O:387998 D:120902
UNIX> <font color=darkred><b>≈</b></font>
</pre>

You can see that X is winning over O significantly, so I think this is a pretty conclusive
experiment!

<hr>
<h3>Summary of the Main Points of this Lecture</h3>

I'm going to write these tomorrow or wednesday.
